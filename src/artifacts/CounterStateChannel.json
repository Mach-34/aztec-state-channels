{
  "name": "CounterStateChannel",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+XdZZOTZxSH8V0gSd27uLu1ySbZJFVK3alSL6Rk6y1V6qXU3XB390/IuWbCwAt4xb0z3HNl5j9590x+m+yj5z7nZE9Pz7aeM6/e7vuC7nv5wl6VQmyjcI7tVssDtVqn0d+pVCtLy/2tdrNertXbA81Ks1Jv1pf1N6vVTrPWbLTarUa5ValVO5XBeqs62N1wId1nLA+FuxjbKA6Bu3iRu0uxjdIQuEuJ3ef7vV/o5xw5RJ9zWOLvqTeheVQm5mEJzaMzMQ9PaB6TiXlEQvPYTMyFhOZxmZiLCc3jMzGXEponZGIemdA8UWieJDRPFpqnCM1TheZpQvN0oXmG0DxTaJ4lNM8WmucIzXOF5nlC83yh+Sah+WahuSw0V4TmfqG5KjTXhOa60DwgNDeE5qbQ3BKabxGabxWabxOabxea7xCa7xSaFwjNdwnNC4Xmu4Xme4Tme4Xm+4Tm+4XmB4TmB4Xmh4Tmh4XmR4TmR4Xmx4Tmx4XmRULzE0Lzk0LzU0Lz00LzM0Lzs0LzYqH5OaH5eaH5BaH5RaH5JaH5ZaH5FaH5VaF5idC8VGhuC82vCc3LhOaO0DwoNL8uNL8hNL8pNL8lNL8tNL8jNL8rNL8nNL8vNC8Xmj8Qmj8Umj8Smj8Wmj8Rmj8VmlcIzZ8JzZ8LzV8IzV8KzV8JzV8Lzd8Izd8KzSuF5u+E5lVC8/dC8w9C849C809C889C8y9C869C829C8+9C8x9C859C819C899C8z9C879C839C8/9C82qheY3QvFZoXic0rxeaNwjNG4XmTULzZqF5i9C8VWjeJjRvF5p3CM07heZdmZgvSWjenYn50oTmPZmYL0to3puJ+fKE5n2ZmK9IaN6fifnKhOYDmZivSmg+mIn56oTmQ5mYr0loPpyJ+dqE5iOZmK9LaD6aifn6hOZjmZhvSGg+non5xoTmE5mY+xKaTyY093W309s1D4+MiBQixUgpwjUh10hcM3AOzTkl51icc3AM5pjEPpp9Fv/D/Kb5jvvO+ntu6r6PioyOjImMjYyLjI9MiEyMTIpMjkyJTI1Mi0yPzIjMjMyKzI7MicyNzIvMjzDjnpnvfInMBGdGNjOjmaHMTGFm7DYizGBlJikzOplZyQxHZhoy4+/0zDtmoi2MMDOLGVLMVGLGEDN3mEHDTBZmlDCzgxkWzHRgxgE9/xdF6AlPj3R6htNDm57S9FheHKEHLz1p6dFKz1J6eNLTkh6P9DxcEqEnXjtCzzR6iNFTix5T9FyiBxE9eehRQ88WepjQ04MeF/R8WB6hJwBr5Fkzzhpq1hSzxnZFhDWYrElkjR5r1ljDxZom1viw5mVlhDURqyLUzFNDTk01NcbU3FKDSk0mNYrU7FHDRk0XNU7U/FADQ00INRLUDPAMnWfKPGPlmSPP4HgmxTMafhPcw+eeNvd4uee5PcI9Me4Rcc+EewhcU3ONyTUX1yCck3OOyjkb5zAc0znGsc9nH8g+gf+R069TXMw0LzyaAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_counter",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "field"
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "increment_multiple",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "increment_single",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+19CZgcx3VezczeAyzuG1gMFvex4PTO7DEgSAx4gLhvAiAIHrvYWQoyCMjAghLlg2YsWZZjR7Rs2ZFpy/ch+racKHEu21GUMEoUJxGTiLksK0qU24mYRLEtyvOa/WP+re0dYLmvljVfT39fT9dUddf7/1f1qquqX1c/kzLmoeqODcFydMzPbgtaq3m0xuRbyA8Wi5Wh/kpQCEby/aXR4YF8cWB0cDgYDgaGB8b6hwuFynBxeKg0WhrKl4JioRKMD5QK41HGrXoY8y54t1XzaHPAu81z3u3VPNod8G5X5j1dfZ8tzhWKukxFukxH+Uneb0aY34ziVlb3DPGoxy0/uy1YqZdXnvGuqu4tUThN8Zno2OaAi7Hk2PrrjolTFe6icFY5yHe10TMOV7xX65eR00ZitSJOqbwdZurms/HHwFXKu3/cXd4Fh7gLgcO8+x3mXXCYd9Fh3gNsM2ui49rouC469kTH9dExFx03RMfe6v716C7VaabaYWe0y5aiuK4onKa4bBTOUNy8KNxCcfOjcCvFdUfhNopbEIXbrTTZytExP8vNwY0530l66SA+rBccoZcuioNeshQH7vMoDnqZT3GQ101xkAd9Sv5rKR0blyV0wpiR3hLDqTWGU1sMp/YYTh0xnDqJh5wH/ZSjY36Wm+Q5XzlPtgFsdgesTOH5pKd5uljCwVu3bp6hzhY60Fm3uXudLSSdLXCgs0W6eYY6W+JAZ4vM3etsCelssQOdLdXNM9TZcgc6W2ruXmfLSWfLHOhshW6eeQd5hjhXOsC5RjfPkpTtKnP3ZbuGyna1A52t1c0z1Nk65Twljx7SCfQH7FlKX0f66lHWV4pkIl/873EnN+S//g7818fgWD+H/BlfE2sTaxNrE+vdYl33DmMVuTlVucFQpyVXtnr3+ZxDHUieG3TzDO9JvYQfXCEnS+lcF3uVuaVIJvLl+SITE25ibWJtYm1ibWJtYm1ibWJtYm1ibWJtYm1ibWL1GSs/r00TFuWxfYjFWFhMjF6wdXqEpc0jLBmPsLR7hKXFIywdHmFp9QhL6h3Gwn49huKQnqY4tI/s/7MxCrP/z6YozP4/m4kn4rZEYfbv2RqF2f9nG4Vx3B6F2UdqRxRmH6mdUZh9pHZFYfaH6ovCCyhudxReRHH3ROHFFAcHyqUUB8fHZRQHh8UVFAdHw5UUBwfBVRQ3EIVXU9xgFGa/raEovJ7iUIZc5ijDXopDGW6kOJThJopDGW6mOJThFopDGW6lOJQhlynKcDvFoQx3UBzKcCfFwV9qF8WhXPsoDuW6m+LgN3QPxaGs8xSHsg4oDv4z/RSH8i9QHMq/SHHwIxmgONSJQYpDnUCZSllcTNXScT3bKOSwjQ7FyBuMwYUwt0m4phwd87PbwjaJ5ZTpP2R1EYaiB1haPcLS4RGWFo+wtHuEJeMRljaPsHR6hCUdg6WgiyW8hfBLCmiHC4QDmPoJR6CskzCPGBwB4YD8POG4RxdHKGJ3DI57CAfk7yYcfbo4QvXvisHRRzggfxfh2KmLI6x6O2Jw7CQckL+DcGzXxRFWwW0xOLiPDfnbCMdWXRxhl2RLDI6thAPytxCOzbo4QrGbYnBsJhyQv4lwbNTFMSx59Mbg2Eg4IL+XcLgYRyJ/vPSOdguyMnTOoajzJn1zHjdyX3kY2CiuFIW5j74nCnP//t4ozGODvVGYxxX3RWEek9wfhXk8g3sBj4VwDx+mOPR3ShSHvuEeisM9916KQ/9kL8WhL3cfxeEeCZztUX7K/sP9Igc+z9jqzRewPxmu47EtfMvYj9qFX/A6C5/9TluW4thfX9lXOsQyz8KC/+scy+225HbPkdyFltyFcyR3sSV38RzJXWnJXWnJne45gQssxsJi6mBZ5RGWpR5hWeARloUeYenyCEu7R1haPMKywiMsKz3CssQjLPM9wtLtEZZOj7C0eYQl4xGW1R5hWeMRlmUeYXE9npkJlkUeYVnsEZasR1jmeYSlwyMsrR5hSb3DWKbz/0A6P1vGHAv7XKy3OElcLgqzzwXmCXldGsy3sR8G5jbZDwNzdQspDnOx7JuBeT72zcDc8RKKwxwh+2tgrpt9MzC/yL4Z0AfrD/fxHorD2IH9MFDvchSH/gj7ZmAMxPORsB/2zUC/iucyUTbsm4Gy4XlQlA37ZqBseA4VZcO+GSgb6Ed4fYnWi8L1XHcgh/0SdsTI2x6DC2G2FVxTjo752W2hrbCcMv2HLPZL2OoBllaPsHR4hGWeR1iyHmFZ7BGWRR5hWe4RlmUeYVnjEZbVHmHJeISlzSMsnR5h6fYIy3yPsCzxCMtKj7Cs8AhLi0dY2j3C0uURloUeYVngEZalHmFZ5RGW9BxhwfgZ+W63sIjcLbpyQxeuzSQX4/otxB/y+T2gTco4UhaOHMl16KcXutH2xvC/k59erzIO4b+ccJTpP88lwS5QPnK/2Zeu4VL26wxxcf17wUy1zQydcyxdw/VguqZD+KCtIS49Vpzk72Jtsx5Lr/Ya6oLP9kVjfPyOlr0eG88r8rUZS0a7cVI+eS4f2XJmavlwO9dmJtsWbC5D55ymMvxUpnadC59hnm+Ma/OV7T10Y4XtGMqfdbiBwnHtYa91HnSqiDOwcUB+juJ6YnBuIJxx6xxqrztr21fKTLUROwwuGwmXso9s3fvpWpKr/F5A6Js7kzUNdxKW3bpYivy+7N1gcfjeRuDgnZRwHeW8cp6SB3/4BPoD9iyl8/s22u/9pEgm8sV/xtfEmmysgmWthZPfdV/rAT7E8Tvdqy39SV/jRXf92GJcP9ael+Z+7KczNVwfpH7sNkuv/Oyada09TkmZyf2Wspl6H+0iLvyOlfKYcdK4Gfk25aqXeWga3AdE3ePyhnzXfdH1MThyhAPyeb1o5b5m2HffGYNjHeGAfO5X7dLFEb6D2heDYxfhgPw+wqHcvws6LRyy3W3/TrnfFPA9526w8H2z3wGWYAZY+P3togMshRlg4XfaBx1gGZgBlkHCMuwAy9AMsAwTlj0OsJRmgGUPYdnrAMu9M8AC+dLPQluwheJgkxsoDrbB/n+oozspDnVlE8WhzHopDrpLUxw4sN/hfVGY5wD3WXFtxA/H/Oy28P4NOch3nyVD8OG93X3usJQ4f57zKpPM/cr8Jc+HlHlIng8r45Q8DkR5tVB5QE6G0l+lOcrPRWGpTw9E6fdRPq/HpGOrZ1sPUZkc1OUazpsdovzLJIPlHtaVG7DcVLRDBuIzFP4ijJrOkw36BWaxn0dizuPwA9Y1WUp/xDHng4SjTP8hS+rJ56lOvU5j0QeV8TBf1ss+0gvS99N5ByiMc3Okt0d0cZYc1PuQ+yHSOXQLOVz3vkzl8RWy4YctvUn6GzHp2OrZONe7I7pcQxs/SvmXSQbLPaYrN2C5sHHIQHyGwl8jGz9WC97WLzCLjR+OOY/DD1vXZCn9sGPORwhHmf5DltSTr1KdeoNsXPn+GDBf1ssB0gvSeV7nEIVxbo70ptw2lhzU+5D7UdI5dAs5XPe+QeXxTbLhg5beJL07MzUdWz0b53p3XJdraOMnKP8yyWC5J3XlBiwXNg4ZiM9QeD4eSNN5skG/wCw2fizmPA4ftK7JUvoxx5yPE44y/YcsqSdpmrvtpufXyvfHgPmyXg6RXpDO83hHKYxzc6Q35bax5KDeh9xPkM6hW8jhureCymMV2fARS2+Svi0mHVs9G+d6d0qXa2jjpyn/MslguWd05QYsFzYOGYjPUHgr2fiZWvC2foFZbPxkzHkcPmJdk6X0k445nyIcZfoPWVJP1lKd2kY2rj12YL6sl6OkF6TzHPkJCuPcHOlNuW0sOaj3IffTpHPoFnK47gVUHgWy4eOW3iT9gZh0bPVsnOvdWV2uoY0/SvmXSQbLPacrN2C5sHHIQHyGwvvJxs/Vgrf1C8xi42dizuPwceuaLKWfccz5LOEo03/IknoySHXqAbJx7bED82W9nCC9IJ2fP52mMM7Nkd6U28aSg3ofcn+UdA7dQg7XvSNUHsfIhk9ZepP0SzHp2OrZONe787pcQxu/QPmXSQbLfUxXbsByYeOQgfgMhR8nG3+sFrytX2AWGz8Xcx6HT1nXZCn9nGPO5wlHmf5DltSTk1SnLpGNa48dmC/r5TTpBemb6LxHKYxzc6Q35bax5KDeh9wvsM6jMORw3atQeTxDNnzW0pukPxeTjq2ejXO9u6jLNbTxxyn/MslguZd05QYsFzYOGYjPUPgW2filWvC2foFZbPyxmPM4fNa6JkvpjznmfJFwlOk/ZEk9eTfVqefIxrXHDsyX9fIo6QXpvXTeBQrj3BzpTbltLDmo9yH3x0nn0C3kcN17gcrjRbLh85beJP2lmHRs9Wyc690TulxDG3+S8i+TDJb7lK7cgOXCxiED8RkKf4Rs/Kla8LZ+gVls/FLMeRw+b12TpfRLjjk/QTjK9B+ypJ58gOrUS2Tj2mMH5st6uUB6QTo91rhd9/ncHOlNuW0sOaj3IfcnSefQLeRw3fs4lcfLZMMXLb1J+isx6djq2TjXu6d1uYY2PkL5l0kGyx3VlRuwXNg4ZCA+Q+FPko2P1oK39ft0dBQbfyrmPA5ftK7JUvpTjjk/TTjK9B+ypJ58gurUK2Tj2mMH5st6eZz0gnReO36Ndb7UZ9gD+xdp2yXfF5Av/nN7jTge/zh8vy7UI7/XZr9fx++TbiNMeJ+0Ef3d7TB8/Pn9M34WE/d+30brPOGn/F5q0cG7Z2F5wwe5hXQDORlK/wzZ8mep/Qdnrg+vxaRjq3d/YF9wZd/nPL97gvvD7hi52n7OLBf3B8hAfIbCX6D7A3/HCfoFZql3fTHncXiDdU2W0vscc+ZvP5XpP7+/8yrVqdeoXcsp42G+rJfVpBek8zumLu2N5bMPrf2tbH6HnNtP7fct+T1c5Iv/fYQPcTnCBx7clvC7WQsdYF1gYcV//taCC7mtltzWOZLbbsltnyO5nZbczjmSm7XkZudI7tzXq2BI8lyinKeU0yIzeat37+VvKyxWxZIPOkxtzdBnKhPHr09UbqYIE3BiXa4uwsVj8gxd02KmcmuLieuIiesyUzf+vtN8Ci+k67otnKJjrIHEaxNjXUdemxg8eB1i8MH57WZqGanefLClrbwL+cFisTLUXwkKwUi+vzQ6PJAvDowODgfDwcDwwFj/cKFQGS4OD5VGS0P5UlAsVILxgVJhPMo8rYhzvV5eeZecVypy3qDIGTcLGIgMZN80b3Ue5LguOvZER9k2RhWvnfS0MkrfSOfJg66MiamkFFdW0knO6OoE22bSTVzj0uaAi7Hk2PrrNo4N30XhbHaQ7xajZ6CueG/RLyOnDVWvYl5bjW5va6YN1TYzfUO1jc7bHnNeOkrfHh1F7g4zedPWvWZ93vkO635XHd3vovP66ui+j3S/O+a8XJS+OzryzIiLtmZHTL6zLac9Kd12QZv3zkin2rzvTblpDzPKOPOKulQs60BTf2/HvgMzvX0HdF4/nTeT/At18i/QeUUzfftRNLX2Y+Bt4hisg2OQzhuqg2OIcAyb6duxYVNrx/DWu4t2bMDo2/P9DdCOlRzw3tcg7dgeRV0qlnWgqb+5GmyuMbptLzCizGV1C1l5Q96C55mitMWLZ7DKSngcDGjzjB1HmQlvJ27GSu+O+LXqYinwTJoh3ZsYXRoz+YtwLbpYwplOPDmuznSevDV69crlI5Xn918bOzlyY+LKyNX9Y2M3KjdvxlWSTAz4NCm0zTqPPx/WQnFpIog4XNNOR2czDrgbcu2Xu+De6HhfdJS59fstDNojMEXLDu43ui2bbf3G6Lds9xo3dzNtnHsVcbJeed0e9kmxdc9GAm6N3BozHxyl5ePvOZqYa1LWNWi123Qx9/N3E42ld1vnhuQ7uIOErTae/1Rb7TOVyzcqE9VWmxtpe8o4HaM/1pvgbFfGWe/5czvJ7dCVG9o91xfoAnL42zH8/e8uZf6SRzYGRxcdIZ+/UZq1dMTfxOykYzrmWpTnPMrD6Y1ThEuj9WaUrxz3m6kLUaWVZfONYrY33f3GzU1Hm/NeRc4PKHPWvsH2mtrUjdHk7fk0gTyy2OOA94MNMk3woKIuFcs60NSfPeAQztJu2u2obA+Ztzdt+LCZftrwYTrvQIRjLjr3Dxn/25wDuvmOF/uLmo8hJ/kGyKI0/NHypA4SuFNkrGtkQCAdPziMXbs+cWX8+eO3rl69Mn6lMibOXazSOFeLuP4yfzM9bjKD+7lz4iOlbQuPGLe2quEmcMBBvgc8v09Wxsfzo2OXg62KnA8q1htN/c3VdLoi/0nt8yHT9N1SKZxDDvI9bPQMyBXvw/pl5NR3S1OnR4w7o1DS55TO3Ww5HzV+3sjezgDkmJl+AHKMzjselYn9TMwYfZtSdILO8yyrK7yaz3ldYVzbABjXNQDGHgcYXeA8bnRtCJusMIdBWtwzcn4Cw4NZ7acr/OjafjStKKfoetCcidFlS4wuWymOfQ2QxhMMxtKLo6dtgd22luk/ZMmgHr4pbw3qH7xRGZmYOqS3/RCYQCpGOSAO0u1WPqzkOfFP4Dy1rfmEXl5z5iPgojV/W+UW1E9mXZyMjrL+WSvpBeeE68PH6CxF4XR0TrrOOalp8pnOep0+G0xHxL+HyIoC3mfJVOySh7K5gtyxGz1UtxsdnJxJXnfokp8ybiqu9nNGTc6n7zqv/suXC5WBoYHBoeJwUCoOjg2PF0qXC+NB/2BlZGikf6w0V/NBp/XymtTFkUXrmvNBs8zzdKRI7XzPGr/ng4T3Wf0ycjI5fyrCqp3vwTmanL/z1fVxatalR/XKOtDUH27ogu95M3cPkV2Nk81Mcc6g94eVDGXVvET1/oQ49/5EAa57f1xBZtv7O2f0DPm8cVNxtXt/mpwv3HVe/vT+LhjdRhKbLIvY7P3NMs8LkSK1871o/O79Ce+L+mXkpPd3PsKqne/hBun9adalx/XKOjjsoPcn+Or1/rRvTqeU6+ld47pDby+GupOeJNaGlnV3p+tJvp/On64n+X5z555kXD5z3pNk4Vp5XooUqd1AXTL6BiYF7brH7MqoZu0O4Ysv3h1GCZcUOT+hWK4z0t8MGjif7UbK1l5EMQ5zfnabqitJDFylvPvH3eVdcIi7EDjMu99h3gWHeRcd5j3ANvNkdMRHCJ6OjiPRcTQ6Xo6OY9GxUt2/Toup23bYaWodCO5Q4IXINMXhpUZ2Y8BLjezGAPcEfmKPhU/5iT0WxrWf5stWjo75WW6uXTo6iA/rBUf7BVN26eCXRMGdXyqFXtjdA/K6KQ7yoE/Jn19Ux8ZlCZ0wZu6w2pxaYzi1xXBqj+HUEcOpk3g4eNE3LPf5ynmyDWCzO9llCs8nPc3TxRK0mVodUMoz72BB7Dzb/t3ojBfJXuBAZ4t088zrL7z9ls58WXhb8lyqm2eos+UOdLbU3L3OlpPOljnQ2QrdPPMO8gxxrnSAc41uniX+aNDdlC1/eGm1A52t1c0z1Nk65Twljx7SCfQH7FlKX0f66lHWV4pkIl/873EnN+S//g7818fgUP7oUl3+jK+JtYm1ibWJ9W6xrnuHsep/ZOutD86wXNnq3edzDnUgeW7QzTO8J/USfvtDXVlK57rYq8wtZSZ/VK9M/xlfE2sTaxNrE2sTaxNrE2sTaxNrE2sTaxNrE2sTa6Ng5ee1acKiPLYPsRgLi4nRC7ZOj7C0eYQl4xGWdo+wtHiEpcMjLK0eYUm9w1jYr8dQHNLTFIf2kf1/NkZh9v/ZFIXZ/2cz8UTclijM/j1bozD7/2yjMI7bozD7SOGzmuwjtTMKs4/UrijM/lB9UXgBxe2OwvzpJHwWkj+yDQdK/sg2HB+XURwcFvlD3nA0XElxcBBcRXEDUXg1xQ1GYfbbGorC6ykOZchljjLspTiU4UaKQxluojiU4WaKQxluoTiU4VaKQxlymaIMt1McynAHxaEMd1Ic/KV2URzKtY/iUK67KQ5+Q/dQHMo6T3Eo64Di4D/TT3Eo/wLFofyLFAc/kgGKQ50YpDjUCZSplMXFVC0d17ONQg7b6FCMvMEYXAhzm4RrytExP7stbJNYTpn+Q1YXYSh6gKXVIywdHmFp8QhLu0dYMh5hafMIS6dHWNIxWAq6WMJbCL+kgHa4QDiAqZ9wBMo6CfOIwREQDsjPE457dHGEInbH4LiHcED+bsLRp4sjVP+uGBx9hAPydxGOnbo4wqq3IwbHTsIB+TsIx3ZdHGEV3BaDg/vYkL+NcGzVxRF2SbbE4NhKOCB/C+HYrIsjFLspBsdmwgH5mwjHRl0c8hXnSXNmwLGRcEB+L+FwMY5E/tIXkv9otyArQ+ccijpv0jfncSP3lYeBjeLwqWruo++Jwty/vzcK89hgbxTmccV9UZjHJPdHYR7P4F7AYyHcw4cpDv2dEsWhb7iH4nDPvZfi0D/ZS3Hoy91HcbhHAmd7lJ+y/3D4IUT4PGOrN1/A/mS4jse28C1jP2oXfsHrLHz430P4EMf++sq+0iGWeRYW/F/nWG63Jbd7juQutOQunCO5iy25i+dI7kpL7kpL7nTPCVxgMRYWUwfLKo+wLPUIywKPsCz0CEuXR1jaPcLS4hGWFR5hWekRliUeYZnvEZZuj7B0eoSlzSMsGY+wrPYIyxqPsCzzCIvr8cxMsCzyCMtij7BkPcIyzyMsHR5hafUIS+odxjKd/wfS+dky5ljY52K9xUniclGYfS4wT8jr0mC+jf0wMLfJfhiYq1tIcZiLZd8MzPOxbwbmjvmTVJgjZH8NzHWzbwbmF9k3A/pg/eE+3kNxGDuwHwbqXY7i0B9h3wyMgXg+EvbDvhnoV/FcJsqGfTNQNjwPirJh3wyUDc+homzYNwNlA/0Iry/RelG4nusO5LBfwo4YedtjcCHMtoJrytExP7sttBWWU6b/kMV+CVs9wNLqEZYOj7DM8whL1iMsiz3CssgjLMs9wrLMIyxrPMKy2iMsGY+wtHmEpdMjLN0eYZnvEZYlHmFZ6RGWFR5hafEIS7tHWLo8wrLQIywLPMKy1CMsqzzCkp4jLBg/I9/tFhaRu0VXbujCtZnkYly/hfhDPr8HtEkZR8rCkSO5Dv30Qjfa3hj+d/LT61XGIfyXE44y/ee5JNgFykfuN/vSNVzKfp0hLq5/L5iptpmhc46la7geTNd0CB+0NcSlx4qT/F2sbdZj6RX/IUvw2b5ojI/f0bLXY+N5Rb42Y8loN07KJ8/lI1vOTC0fbufazGTbgs1l6JzTVIafytSuc+EzzPONcW2+sr2HbqywHUP5sw43UDiuPey1zoNOFXEGNg7Iz1FcTwzODYQzbp1D7XVnbftKmak2YofBZSPhUvaRrXs/XUtyld8LCH1zZ7Km4U7CslsXS5Hfl70bLA7f2wgcvJMSrqOcV85T8uAPn0B/wJ6ldH7fRvu9nxTJRL74z/iaWJONVbCstXDyu+5rPcCHOH6ne7WlP+lrvOiuH1uM68fa89Lcj/10pobrg9SP3WbplZ9ds661xykpM7nfUjZT76NdxIXfsVIeM04aNyPfplz1Mg9Ng/uAqHtc3pDvui+6PgZHjnBAPq8XrdzXDPvuO2NwrCMckM/9ql26OMJ3UPticOwiHJDfRziU+3dBp4VDtrvt3yn3mwK+59wNFr5v9jvAEswAC7+/XXSApTADLPxO+6ADLAMzwDJIWIYdYBmaAZZhwrLHAZbSDLDsISx7HWC5dwZYIF/6WWgLtlAcbHIDxcE22P8PdXQnxaGubKI4lFkvxUF3aYoDB/Y7vC8K8xzgPiuujfjhmJ/dFt6/IQf57rNkCD68t7vPHZYS589zXmWSuV+Zv+T5kDIPyfNhZZySx4EorxYqD8jJUPqrNEf5uSgs9emBKP0+yuf1mHRs9WzrISqTg7pcw3mzQ5R/mWSw3MO6cgOWm4p2yEB8hsJfhFHTebJBv8As9vNIzHkcfsC6JkvpjzjmfJBwlOk/ZEk9+TzVqddpLPqgMh7my3rZR3pB+n467wCFcW6O9PaILs6Sg3ofcj9EOoduIYfr3pepPL5CNvywpTdJfyMmHVs9G+d6d0SXa2jjRyn/Mslgucd05QYsFzYOGYjPUPhrZOPHasHb+gVmsfHDMedx+GHrmiylH3bM+QjhKNN/yJJ68lWqU2+QjSvfHwPmy3o5QHpBOs/rHKIwzs2R3pTbxpKDeh9yP0o6h24hh+veN6g8vkk2fNDSm6R3Z6amY6tn41zvjutyDW38BOVfJhks96Su3IDlwsYhA/EZCs/HA2k6TzboF5jFxo/FnMfhg9Y1WUo/5pjzccJRpv+QJfUkTXO33fT8Wvn+GDBf1ssh0gvSeR7vKIVxbo70ptw2lhzU+5D7CdI5dAs5XPdWUHmsIhs+YulN0rfFpGOrZ+Nc707pcg1t/DTlXyYZLPeMrtyA5cLGIQPxGQpvJRs/Uwve1i8wi42fjDmPw0esa7KUftIx51OEo0z/IUvqyVqqU9vIxrXHDsyX9XKU9IJ0niM/QWGcmyO9KbeNJQf1PuR+mnQO3UIO172AyqNANnzc0pukPxCTjq2ejXO9O6vLNbTxRyn/Mslgued05QYsFzYOGYjPUHg/2fi5WvC2foFZbPxMzHkcPm5dk6X0M445nyUcZfoPWVJPBqlOPUA2rj12YL6slxOkF6Tz86fTFMa5OdKbcttYclDvQ+6Pks6hW8jhuneEyuMY2fApS2+SfikmHVs9G+d6d16Xa2jjFyj/MslguY/pyg1YLmwcMhCfofDjZOOP1YK39QvMYuPnYs7j8Cnrmiyln3PM+TzhKNN/yJJ6cpLq1CWyce2xA/NlvZwmvSB9E533KIVxbo70ptw2lhzU+5D7BdZ5FIYcrnsVKo9nyIbPWnqT9Odi0rHVs3Gudxd1uYY2/jjlXyYZLPeSrtyA5cLGIQPxGQrfIhu/VAve1i8wi40/FnMeh89a12Qp/THHnC8SjjL9hyypJ++mOvUc2bj22IH5sl4eJb0gvZfOu0BhnJsjvSm3jSUH9T7k/jjpHLqFHK57L1B5vEg2fN7Sm6S/FJOOrZ6Nc717QpdraONPUv5lksFyn9KVG7Bc2DhkID5D4Y+QjT9VC97WLzCLjV+KOY/D561rspR+yTHnJwhHmf5DltSTD1CdeolsXHvswHxZLxdIL0inxxq36z6fmyO9KbeNJQf1PuT+JOkcuoUcrnsfp/J4mWz4oqU3SX8lJh1bPRvneve0LtfQxkco/zLJYLmjunIDlgsbhwzEZyj8SbLx0Vrwtn6fjo5i40/FnMfhi9Y1WUp/yjHnpwlHmf5DltSTT1CdeoVsXHvswHxZL4+TXpDOa8evsc6X+gx7YP8ibbvk+wLyxX9urxHH4x+H79eFeuT32uz36/h90m2ECe+TNqK/ux2Gjz+/f8bPYuLe79tonSf8lN9LLTp49ywsb/ggt5BuICdD6Z8hW/4stf/gzPXhtZh0bPXuD+wLruz7nOd3T3B/2B0jV9vPmeXi/gAZiM9Q+At0f+DvOEG/wCz1ri/mPA5vsK7JUnqfY8787acy/ef3d16lOvUatWs5ZTzMl/WymvSCdH7H1KW9sXz2obW/lc3vkHP7qf2+Jb+Hi3zxv4/wIS5H+MCD2xJ+N2uhA6wLLKz4z99acCG31ZLbOkdy2y257XMkt9OS2zlHcrOW3OwcyZ37ehUMSZ5LlPOUclpkJm/17r38bYXFqljyQYeprRn6TGXi+PWJys0UYQJOrMvVRbh4TJ6ha1rMVG5tMXEdMXFdZurG33eaT+GFdF23hVN0jDWQeG1irOvIaxODB69DDD44v91MLSPVmw+2tJV3IT9YLFaG+itBIRjJ95dGhwfyxYHRweFgOBgYHhjrHy4UKsPF4aHSaGkoXwqKhUowPlAqjEeZpxVxjurllXfJeaUi5zFFzrhZwEBkEPmmeWsALMeno+NIdJRtPKp47aSnlVH6OJ33jHmr0k6ppBRXVtLJZaOrE2zvIt3ENS5tDrgYS46tv27j2PBdFM67HOR7xegZqCveV/TLyGlDVVHM691Gt7c104bqW8z0DdW30HlXY85LR+lXo6PIfdZM3rR1r1mfr73Dur9eR/fX6bz31NH9e0j33xpz3uUo/VujozSWN6I0F23NszH5zracjqd02wVt3tcinWrzPpFy0x5mlHHeVNSlYlkHmvp7O/Y9Yaa37wk67xadN5P8n6uT/3N03nvN9O3He02t/Xjf28TxfB0cz9N576+D4/2E49vM9O3Yt5laO/btUZqLdux9Rt+eTzdAO/btDnifaZB27DsUdalY1oGm/uZqsPmk0W17gRFl/p3mrRXEvstMnilKW7x4BqushMfBgDbP2HGUmfB24mas9O6IX6sulgLPpBnSvYnRpTGTvwjXooslnOnEk+PqTOfJW6NXr1w+Unl+/7WxkyM3Jq6MXN0/NnajcvNmXCXJxIBPk0LbrPP482EtFJcmgojDNe10dDbjgLsh1365C74QHb8rOsrc+osWBu0RmKJlBy8a3ZbNtn5j9Fu27zRu7mbaOF9QxMl6/QvR8bvNZJ8UW/dsJODWyK0x88FRWj7+nqOJuSZlXYNWu00Xcz9/N9FYerd1bki+gztI2Grj+U+11T5TuXyjMlFttbmRtqeM0zH6Y70JznZlnPWeP7eT3A5duaHdc32BLiCHvx3D3//uUuYveWRjcHTREfL5G6VZS0f8TcxOOqZjrkV5zqM8nN44Rbg0WnKD/O7o+IHq/kFLZlpZNt8oZnvT/YBxc9PR5vyCIucPKnPWvsHKY4BbRn+4fM7zaQJ5ZPEdDnifb5Bpgu9R1KViWQea+rMHHMJZ2k27HZXtQ+btTRt+r5l+2vB76bwPRzjmonP/IeN/m/Nh3XzHi/1FzceQk3wDvs9M/mh5UgcJ3Cky1jUyIJCOHxzGrl2fuDL+/PFbV69eGb9SGRPnLlZpnKtFXH+Zv5keN5nB/dw58ZHStoXvM25tVcNN4MMO8r3o+X2yMj6eHx27HLxbkfNfVKw3mvqbq+l0Rf6T2ufvN03fLZXC+X4H+f6A0TMgV7x/QL+MnPpuaer0Lxl3RqGkzymdu9ly/ojx/0amPamxTpHzS4q47EGXvGErg6a10fGl6NhjaoOpHzTTD7p+kM77aFQP7eeAxui3I4qO33meWXaFd43Rr7faGNc2AMaXGgBjj3HTRmnj/KjRtSFsP2RqA9M4vwB+6sQDeO0nSvy43n4cryin6HqiIBOjy5YYXbZSHPtXII0nVYylF0dPGAO7bS3Tf8iSiQz447w1kfHgjcrIxNRpDNv3ggmkYpQD4iDdbuXDSp4TnwzOU9uaf0gvrzkbomreFeOceX64un+suv+IaXp8NT2+kubxJbVf+uYfi44/YmoeXz9qYdAeMytadvCjRrdlazVTN+2WLa2I2SVOzXGUS5w/3CA4P2Z072jNcWlzXKqFUXNcyjdS3Dv+cnX/uJm8Upnd1vINNUVxuEHyjReebXzjRQ+HxxDaHm6NOEbkYQ4/iEEc9MU9RVzTYaaWTWdM2XSRrEXWecZM7XEqe0DWXYGng45YLaTy7JWJh69dvvH8e6pjyaPXn+GOVwdxsfHLxj3buOFkytR0xXUxq8u5n+u8IdnG0gO2LGFxYRfzdPMM2zpe6QVc5xEfpHcQt/nK3FJm8uozZfo/353ckH/3Hfh3x+DonkP+3YQtzmMX6ezVnrZ4cLuE89+xqZbZDm5+zOhWAO0bfa9563MI2rwvee5lKh2PvAPeTzSIl+nLirpULOvgCc/rjXhdPeOg3jzdAF7ZNx3wHmkQe/lxRV0qlnUw4nm9kc+WHXVQb8bmqN7k3/4WOsccVuT8E4rlMuZ5vRHnp484qDfjDVJvNB3JPqFYLq70p+1UlVLU30+axuCcVuT8Uw3COaPI+acbhHOLIuefaRDOrYqcf7ZBOLcpcv65BuHcrsj55xuE848pcv6FBHL+xQRy/qUEcv5kAjm/0iCcX1bk/MsNwvnHFTn/SoNw1qzbv5pAzr+WQM6/nkDOv5FAzr+ZQM6/lUDOn0og599OIOe/kkDOfzWBnD+dQM5/LYGc/3oCOf9OAjn/jQRy/psJ5Py3Esj5byeQ899JIOffTSDn30sg599PIOe/m0DOn0kg57+XQM6fTSDnv59Azv8ggZxfTSDnf5hAzp9LIOd/lEDO/ziBnD+fQM7/JIGc/yCBnP9pAjn/swRy/ucJ5PyFBHJ+LYGc/0UCOf/LBHL+Vwnk/MUEcn49gZz/dQI5/5sEcv63CeT87xLI+d8nkPMfJpDzlxLI+Y8SyPnLCeT8HxLI+SsJ5PwfE8j5PyWQ81cTyPk/J5Dzf2kQzscVOf/XBuH8UUXO/61BOGvW7f+eQM7/I4Gc/2cCOf9xAjn/rwRy/t8J5Py1BHJ+I4Gc/08COf/fBHL+fwnk/PUEcv7/CeT8Jw3C+SFFzn/aIJw/pMj5zxqEs2bd/kYCOb+ZQM7fTCBn0yDrrGtyTiWQczqBnDMJ5NySQM6tCeTclkDO7Qnk3JFAzp0J5NzVIJx/QpFztkE4f0KR87wE1u35CeTcnUDOCxLIeWECOS9KIOfFCeS8JIGclyaQ87IEcl6eQM4rEsh5ZQI5r0og59UJ5LwmgZzXJpDzugRy7kkg5/UJ5JxLIOcNCeTcm0DOGxPIeVMCOW9OIOctCeS8NYGctyWQ8/YEct7RIJw7FDnvbBDOnYqcdzUI5y5Fzn0NwjmryHl3g3Cep8j5ngbhPF+Rc75BOHcrcg4ahPMCRc79DcJ5oSLnQoNwXqTIudggnBcrch5oEM5LFDkPNgjnpYqchxqE8zJFzsMNwnm5IueSIuflUT6piHOmurdU99bq3lbd26u7jAlljCRjBulDS59S+ljS55B7sNyTpI2WNktsWOq0lPFy0ufL0fEnq/tPVfefru4/U91/trr/XHX/+er+C9X9F6v7L1X3T1b3V6r7L1f3X6nuv1rdf626/3p1/43q/pvV/beq+6eq+29Xd/nGvXzzXb6BLt8El29k/051l28oyzeF5Ru78s1Z+Qbr71b336vuv1/d5RuO8k1D+caffPNOvgEn30STb4TJN7PkG1LyTSX5xpB8c0e+QfMH1V2+USLf7JBvWMg3HeQbB7Lmv6yBL2vCyxrpr1d3WUNb1pSWNZZlzWFZg/cPq/uXqvsfVXdZw1PWtJQ1HmXNQ1kDUNbEkzXiZM00WUNM1tSSNaZkzSVZg+iPq7usUSNrtsgaJrKmh6xxIWs+yBoIsiaAvCP/J9Vd3qGWd4rlHVt551TewZTClnf05J01eYdL3mmSd3zknRd5B0TeiZB3BMRnXnzIxadafIzF51Z8UMUnU3wUxWdPfNjEp0t8nMTnR3xgxCdEfCTEZ0CeocszZXnGKs8c5RmcPJOSZzTyzELm8GVOW+Z4Zc5T5gBlTkzmiGTOROYQZEwtY0wZc8kYRPrk0keVPpv0YeSeLvc4afOlDZQ2QWwkTfWvIzrujY5nJq7fGHmmkrt59fpELp+7Vv0duXr1+nsrY7tznHYz9+ytmxO5mxMjNyZy4zeuP5sLdsv1T0b5DETHB6/fujZRuZF718jNakY3KiNjz+dGK5VruSvXLt+oPFupJo7lJq7nrlRzrFwbyz03cvVW5c8BKatWFd6MAgA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "init_counter",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "start",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "end",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJzt3d+u5LhxwOF3metFoPpDUtxXCXJhJA5gwHCC2HfGvntkZLvPGURa7lg8zV+TdeWF0b2qKm6Xipz5pL9/+/N//fsf/van//rLX7/9/Pdv279I+vbzv/7921//+w9/+cf/8de//eF//vbt5+2nb3/8y38c//vLT9/+809//uO3n+WXn/7fp9Q92a+fPP45l+enaz75uJTy+PD28S+29Mu//fSPQDIlkEIJZKcEUiGB6EYJRCiBKCUQowTilEAonVUpnVUpnVUpnVUpndUondUondUondUondUondUondUondUondUondUondUpndUpndUpndUpndUpndUpndUpndUpndUpndUpnTVROmuidNZE6ayJ0lkTpbMmSmdNlM6aKJ01UTpronTWTOmsmdJZM6WzZkpnzZTOmimdNVM6a6Z01kzprJnSWQulsxZKZy2UzloonbVQOmuhdNZC6ayF0lkLpbMWSmfdKZ11p3TWndJZd0pn3Smddad01p3SWXdKZ90pnXWndNZK6ayV0lkrpbNWSmetlM5aKZ21UjprpXTWSumsldJZZaO0VtkovVU2SnOVjdJdZaO0V9ko/VU2SoOVjdJhZaO0WNkwPVYwPVYwPVYwPVYwPVYwPZZjsjgoi6OyOCwL47IEA7MEI7MEQ7MEY7MEg7MEo7MEw7ME47MEA7QEI7QEQ7QEY7QEg7QEo7QEw7QE47QEA7UEI7UEQ7UEY7UEg7UEo7UEw7UE47UEA7YEI7YEQ7YEY7YEg7YEo7YEw7YE47YEA7cEI7cEQ7cEY7cEg7cEo7cEw7cE47cEA7gEI7gEQ7gEY7gEg7gEo7gEw7gE47gEA7kEI7kEQ7kEY7kEg7kEo7kEw7kE47kEA7oEI7oEQ7oEY7oEg7oEo7oEw7oE47oEA7sEI7sEQ7sEY7sEg7sEo7sEw7sE47sEA7wEI7wEQ7wEY7wEg7wEo7wEw7wE47wU47wU47wU47wU47x0o/RYxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvwzgvwzgvwzgvwzgv2yg91jDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzDOyzHOyzHOyzHOyzHOyzdKj3WM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM83KM80oY55UwzithnFfCOK+0UXpswjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjiv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ON0Ww8eOUDjdFgPIjlA43RZDyI5QON0Wg8iOUDjdFsPIjlA43RYDyY5QON0WQ8mOUDDdVjiWTDiWTDiWTDiWTDZMtxWOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJROOJVOOJVOOJVOOJVOOJdMN022VY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mUY8mMY8mMY8mMY8mMY8lsw3Rb41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy41gy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",
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "eJzN3c2OJllynOF76fVASHc/P+FzK4IWhEQBBAhSELkj5t4VA3Rm94h+JrzeDmbZikOgrOPrLItT1U+EZf7HL//8r//zH/79n/71X/7tlz//xy8f/23/8uf//h+//Nv/+Yd/+ev//2///g//999/+fPHn375x3/5X/f//cuffvnf//TP//jLn+0vf/pPv8rHyM9f6WN+jK9fnav45bb35y/++O0fHPMv/+NP9+e4RD5HinwO+1D5IKbyQVzlg4TKBxkqH2SqfJCl8kFUzlVTOVhN5WR1lZPVVU5WVzlZXeVkdZWT1VVOVlc5WV3lZHWVk9VVTtZQOVlD5WQNlZM1VE7WUDlZQ+VkDZWTNVRO1lA5WUPlZB0qJ+tQOVmHysk6VE7WoXKyDpWTdaicrEPlZB0qJ+tQOVmnysk6VU7WqXKyTpWTdaqcrFPlZJ0qJ+tUOVmnysk6VU7WpXKyLpWTdamcrEvlZF0qJ+tSOVmXysm6VE7WpXKyLpWTdaucrFvlZN0qJ+tWOVm3ysm6VU7WrXKybpWTdaucrFvlZL1UTtZL5WS9VE7WS+VkvVRO1kvlZL1UTtZL5WS9VE7WS+VkTZWTNVVO1lQ5WVPlZE2VkzVVTtZUOVlT5WRNlZM1VU5W+1A5Wu1D5Wy1D5XD1T5UTlf7UDle7UPlfLUPlQPWPlROWPtQOWLtQ+aMFZpjyZyxOoMsnUWWziRLZ5OlM8rSWWXpzLJkdlkmM8wymWWWyUyzTGabZTLjLJNZZ5nMPMtk9lkmM9AymYWWyUy0TGajZTIjLZNZaZnMTMtkdlomM9QymaWWyUy1TGarZTJjLZNZa5nMXMtk9lomM9gymcWWyUy2TGazZTKjLZNZbZnMbMtkdlsmM9wymeWWyUy3TGa7ZTLjLZNZb5nMfMtk9lsmM+AymQWXyUy4TGbDZTIjLpNZcZnMjMtkdlwmM+QymSWXyUy5TGbLZTJjLpNZc5nMnMtk9lwmM+gymUWXyUy6TGbTZTKjLpNZdZnMrMtkdl0mM+wymWWXyUy7TGbbZTLjLpNZd5nMvMtk9l0mM/AymYWXyUy8TGbjZTIjL5NZeZnMzMtkdl4us/NymZ2Xy+y8XGbn5R8qZ6zL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z83KZnZfL7LxcZuflMjsvl9l5uczOy2V2Xi6z8wqZnVfI7LxCZucVMjuv+FA5Y0Nm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmd15DZeQ2ZndeQ2XkNmZ3X+FA5Y4fMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8rsvKbMzmvK7LymzM7rjst8EpUzdsrsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryey8lszOa8nsvJbMzmt9qJyxS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZHZeS2bntWR2Xktm57Vkdl5LZue1ZXZeW2bntWV2Xltm57U/VM7YLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89oyO68ts/PaMjuvLbPz2jI7ry2z89r1ziuusX5NxbX9736ea85ff+n11w/w+StjFL82vz6Mffj87YPvz09TnrM/7dOUZ+1P+zTlefuzPk29+/ppn6Y8d3/apynP3p/2acrz96d9mvIM/mmfpjyHf9qnkTqL603YT/s0UmdxvQ37SZ/mqvdhP+3TKJ3FV70T+2mf5g+fxbnttytcDx/n+sjPjz6vv/uPtcivf+74+P0/9+uj/+GD++d99D98yv+8j/6H/0j4eR/9D//58fM++h/+w+bnffQ//CfTT/vo9QTvbz76NX53jV9Tz3/cVKnnPxaq1PPxXaWeT84q9XxoVann86JKPd+qVer5LqlSzwUtUvV06DGFulFPch5TqBv11OUxhbpRT0geU6gb9TTjMYW6UU8eHlOoG/WU4DGFulG/ov+YQt2oX31/TKFu1K+UP6ZQN+pXtR9TqBv1K9CPKdSN+tXixxTqRv3K7mMKdaN+FfYxhbpRv2L6mELdqF/dfEyhbtSvRD6mUDfqVw0fU6gb9St8jynUjfrVuMcU6kb9ytljCnWjfpXrMYW6Ub8i9ZhC3ahfPXpMoW7Ur/Q8plA36ldlHlOoG/UrKI8p1I361Y7HFOpG/crEYwp1o34V4TGFulE/4n9MoW7Uj84fU6gbjUfSVQp1o/GIt0qhbjQemVYp1I3GI8gqhbrReKRXpVA3Go/IqhTqRuORU5Ui3cjGI5wqRbqRjUciVYp0IxtPDaoU6UY2rLxKkW5kQ4irFOoGctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELmofCEbvGGnHHSP1uGOkH3eMFOSOkYbcMVKRO0Y6csdISe4Yawki0jvGWoKQ9I6xliAmvWOsJQhK7xhrCaLSO8ZagrD0jrGWIC69Y6wlCEz/OlJhMdYSZKZ/fQudxVhLEJveMdYSBKd3jLUE0ekdYy1BeHrHWEsQn94x1hIEqHeMtQQR6h1jLUGIesdYSxCj3jHWEgSpd4y1BFHqHWMtQZh6x1hLEKfeMdYSBKp3jLUEkeodYy1BqHrHWEsQq94x1hIEq3eMtQTR6h1jLUG4esdYSxCv3jHWEgSsd4y1BBHrHWMtQch6x1hLELPeMdYSBK13jLUEUesdYy1B2HrHWEsQt94x1hIErneMtQSR6x1jLUHoesdYSxC73jHWEgSvd4y1BNHrHUMtMWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavfmDNHJ8/72N8/O6Hq319n/o7WP8WNIL1b0IjWP82PAcPvNkI1r8VjWD9m9EI1jdtI1jfto1gfeM2grQ5B+xsBGlzDuD5HDyQZyNIm3Ngz0aQNudAn40gbc6BPxtB2pwDgTaCtDkHBm0EaXMOFNoI0uYcOLQRpM05kGgjSJtzYNFGkDbnQKONIG3OgUcbQdqcA5E2grQ5ByZtBGlzDlTaCMLmxIFLG0HYnDiQaSMImxMHNm0EYXPiQKeNIGxOHPi0EaTNORBqI0ibc2DURpA250CpjSBtzoFTG0HanAOpNoK0OQdWbQRpcw602gjS5hx4tRGkzTkQayNIm3Ng1kaQNudArY0gbc6BWxtB2pwDuTaCtDkHdm0EaXMO9NoI0uYc+LURpM05EGwjSJtzYNhGkDbnQLGNIG3OgWMbQdqcA8k2grQ5B5ZtBGlzDq/FNoK0OdSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkhb2rImxrypoa8qSFvasibGvLuGPIug43m1MFGc+pgozl1sNGcOthoTh1sNKcONppTBxvNKYMdQ66DtDkdQ66DtDkdQ66DtDkdQ66DtDkdQ66DtDkdQ66DtDkdQ66DtDkdQ66DtDkdQ66DtDkNQ7b1N8E//adfvZb/+ovXnl+/NubXNZ5L9oev0ZDpP36N5+r+0WtcDSb7/67xa7DBZIfgD/9bfQafb8hDsLwhZ6zxa3AOs9+C999dPoPlDdkJljdkJ1jekJ1geUN2guUN2QmWzWkEaybrBMvmdIJlczpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pyayTpB2pwatDpB2pz6VctOkDanftWyE6TNqV+17ARpc+pXLTtB2JysX7XsBGFzsn7VshOEzckP2JysX7XsBGFzsn7VshOEzcnakBvB2pA7Qdqc2pA7QdocashJDTmpISc15KSGnNSQkxpyUkNOashJDTmp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"
    ],
    "fileMap": {
      "1": {
        "source": "mod counter_note;\nmod value_note;\n\ncontract CounterStateChannel {\n    use dep::std::option::Option;\n    use dep::aztec::{\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::{\n            map::Map,\n            singleton::Singleton\n        },\n        selector::compute_selector,\n    };\n    use crate::counter_note::{CounterNote, CounterNoteMethods, COUNTER_NOTE_LEN};\n\n    struct Storage {\n        counters: Map<Singleton<CounterNote, COUNTER_NOTE_LEN>>,\n    }\n\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                counters: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        Singleton::new(context, slot, CounterNoteMethods)\n                    },\n                ),\n            }\n        }\n    }\n\n    #[aztec(private)]\n    fn constructor() { }\n\n    /**\n     * Initialize a new counter for a given user\n     * @notice: mocks staking to start a new channel\n     * \n     * @param start - the value to start the counter at\n     * @param end - the value to conclude the counter at\n     */\n    #[aztec(private)]\n    fn init_counter(start: Field, end: Field) {\n        // get the msg sender as the owner\n        let owner = context.msg_sender();\n        // get the singleton from storage\n        let counter_singleton =  storage.counters.at(owner);\n        // check to see if the counter has already been initialized\n        // unreachable since unconstrained :( how to check if initialized???\n        // assert(\n        //     counter_singleton.is_initialized(Option::some((owner))) == false,\n        //     \"Counter has already been initialized for this account\"\n        // );\n        // // initialize a new singleton for the counter\n        counter_singleton.initialize(\n            &mut CounterNote::new(owner, start, end),\n            Option::some(owner),\n            true\n        );\n    }\n\n    /**\n     * Increment the counter once (testing util)\n     */\n    #[aztec(private)]\n    fn increment_single() {\n        // get the msg sender as the owner\n        let owner = context.msg_sender();\n        // get the singleton from storage\n        let counter_singleton = storage.counters.at(owner);\n        // check that the counter can be incremented\n        let mut counter = counter_singleton.get_note(false);\n        assert(\n            counter.value as u120 < counter.end as u120,\n            \"Counter has already been incremented to its end value\"\n        );\n        // increment value in note and replace in storage\n        counter.value += 1;\n        counter_singleton.replace(&mut counter, true);\n        // @todo: publicly mark counter as complete if start == end\n    }\n\n    /**\n     * Increment the counter recursively until it reaches the end value\n     * @notice: DO NOT INCREMENT MORE THAN 64 TIMES (current call stack limit)\n     */\n    #[aztec(private)]\n    fn increment_multiple() {\n        // get the msg sender as the owner\n        let owner = context.msg_sender();\n        // get the singleton from storage\n        let counter_singleton = storage.counters.at(owner);\n        // get the counter note from storage\n        let mut counter = counter_singleton.get_note(false);\n        // increment value in note and replace in storage\n        counter.value += 1;\n        counter_singleton.replace(&mut counter, true);\n        // if the counter has not reached its end value, increment again\n        if counter.value as u120 < counter.end as u120 {\n            context.call_private_function(\n                context.this_address(),\n                compute_selector(\"increment_multiple\"),\n                []\n            )\n        }\n    }\n\n    unconstrained fn get_counter(owner: Field) -> Field {\n        storage.counters.at(owner).view_note().value\n    }\n\n    // unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; VALUE_NOTE_LEN]) -> [Field; 4] {\n    //     let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n    //     note_utils::compute_note_hash_and_nullifier(ValueNoteMethods, note_header, preimage)\n    // }\n\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; COUNTER_NOTE_LEN]) -> [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(CounterNoteMethods, note_header, preimage)\n    }\n}\n",
        "path": "/home/jpag/Workground/aztec/statechannel/contracts/src/main.nr"
      },
      "19": {
        "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    pub fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\npub fn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\npub fn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
        "path": "std/grumpkin_scalar.nr"
      },
      "20": {
        "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
        "path": "std/grumpkin_scalar_mul.nr"
      },
      "35": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "94": {
        "source": "use dep::protocol_types::constants::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    BLOCK_HEADER_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__BLOCK_HASH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:block-header\nstruct BlockHeader {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    archive_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:block-header\n\nimpl BlockHeader {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; BLOCK_HEADER_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.archive_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn deserialize(deserialized: [Field; BLOCK_HEADER_LENGTH]) -> Self {\n        BlockHeader {\n            note_hash_tree_root: deserialized[0],\n            nullifier_tree_root: deserialized[1],\n            contract_tree_root: deserialized[2],\n            l1_to_l2_messages_tree_root: deserialized[3],\n            archive_root: deserialized[4],\n            public_data_tree_root: deserialized[5],\n            global_variables_hash: deserialized[6],\n        }\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, archive_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n\n    pub fn block_hash(self) -> Field {\n        // TODO(#3442): Unify the ordering in `BlockHeader::serialize` function and the ordering\n        // in the block hash preimage --> This requires changes in the circuits.\n        let inputs = [\n            self.global_variables_hash,\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.public_data_tree_root\n        ];\n        pedersen_hash(inputs, GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_header.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "95": {
        "source": "use dep::protocol_types::constants::GENERATOR_INDEX__CONTRACT_ADDRESS;\nuse crate::hash::pedersen_hash;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n    pedersen_hash([pub_key_x, pub_key_y, partial_address],\n        GENERATOR_INDEX__CONTRACT_ADDRESS)\n}\n",
        "path": "/aztec/address.nr"
      },
      "96": {
        "source": "use dep::protocol_types::constants::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    BlockHeader,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n    get_block_header::get_block_header,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_header: inputs.block_header,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: Field) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_header: BlockHeader {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    archive_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n",
        "path": "/aztec/context.nr"
      },
      "97": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse dep::protocol_types::constants::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    // TODO(#1205) This is probably not the right index to use\n    pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    pedersen_hash_with_separator(inputs, hash_index)\n}\n",
        "path": "/aztec/hash.nr"
      },
      "98": {
        "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse crate::types::point::Point;\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/aztec/log.nr"
      },
      "103": {
        "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse dep::protocol_types::constants::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note, note_interface: NoteInterface<Note, N>) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}\n",
        "path": "/aztec/note/lifecycle.nr"
      },
      "104": {
        "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>, note: Note) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(context: &mut PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields)[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields);\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>, options: NoteViewerOptions<Note, N>) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields)\n}\n\nunconstrained fn flatten_options<Note, N>(selects: BoundedVec<Option<Select>, N>, sorts: BoundedVec<Option<Sort>, N>) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}\n",
        "path": "/aztec/note/note_getter.nr"
      },
      "106": {
        "source": "use crate::hash::pedersen_hash;\nuse dep::protocol_types::constants::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/aztec/note/note_hash.nr"
      },
      "110": {
        "source": "use dep::protocol_types::constants::GENERATOR_INDEX__OUTER_NULLIFIER;\nuse crate::{\n    note::{\n        note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n    utils::arr_copy_slice,\n    hash::pedersen_hash,\n};\n\npub fn compute_inner_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note_with_header);\n\n    let input = [header.contract_address, inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(note_interface: NoteInterface<Note, N>, note_header: NoteHeader, serialized_note: [Field; S]) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/aztec/note/utils.nr"
      },
      "112": {
        "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n",
        "path": "/aztec/oracle/arguments.nr"
      },
      "113": {
        "source": "use dep::protocol_types::constants::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(_contract_address: Field, _function_selector: Field, _args_hash: Field) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained pub fn call_private_function_internal(contract_address: Field, function_selector: Field, args_hash: Field) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(contract_address, function_selector, args_hash)\n}\n",
        "path": "/aztec/oracle/call_private_function.nr"
      },
      "119": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: Field) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key_x = result[0];\n    let pub_key_y = result[1];\n    let partial_address = result[2];\n\n    let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n    assert(calculated_address == address);\n\n    Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/aztec/oracle/get_public_key.nr"
      },
      "120": {
        "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(_owner: Point) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\npub fn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
        "path": "/aztec/oracle/get_secret_key.nr"
      },
      "122": {
        "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n",
        "path": "/aztec/oracle/rand.nr"
      },
      "126": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(_storage_slot: Field, _serialized_note: [Field; N], _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(storage_slot: Field, serialized_note: [Field; N], inner_note_hash: Field) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        return_size,\n        placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS] // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n",
        "path": "/aztec/oracle/notes.nr"
      },
      "128": {
        "source": "use crate::types::point::Point;\nuse dep::protocol_types::constants::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(_contract_address: Field, _storage_slot: Field, _encryption_pub_key: Point, _preimage: [Field; N]) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(contract_address: Field, storage_slot: Field, encryption_pub_key: Point, preimage: [Field; N]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(contract_address, storage_slot, encryption_pub_key, preimage), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: Field, _event_selector: Field, _message: T) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(contract_address: Field, event_selector: Field, message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n",
        "path": "/aztec/oracle/logs.nr"
      },
      "129": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse dep::protocol_types::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::hash::pedersen_hash;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    pub fn hash(self) -> Field {\n        pedersen_hash([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n",
        "path": "/aztec/private_call_stack_item.nr"
      },
      "134": {
        "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse crate::hash::pedersen_hash;\n\n// docs:start:map\nstruct Map<V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<V> Map<V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Map<V> {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: Field) -> V {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
        "path": "/aztec/state_vars/map.nr"
      },
      "137": {
        "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__INITIALIZATION_NULLIFIER};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    get_secret_key::get_secret_key,\n    notes::check_nullifier_exists,\n};\nuse crate::hash::pedersen_hash;\n\npub fn compute_singleton_initialization_nullifier(storage_slot: Field, owner: Option<Field>) -> Field {\n    if owner.is_some() {\n        let secret = get_secret_key(owner.unwrap_unchecked());\n        pedersen_hash([storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER)\n    } else {\n        pedersen_hash([storage_slot], GENERATOR_INDEX__INITIALIZATION_NULLIFIER)\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note,\n        owner: Option<Field>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(\n        self,\n        new_note: &mut Note,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self, broadcast: bool) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n",
        "path": "/aztec/state_vars/singleton.nr"
      },
      "141": {
        "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}\n",
        "path": "/aztec/types/vec.nr"
      },
      "147": {
        "source": "pub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n",
        "path": "/aztec/utils.nr"
      },
      "153": {
        "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        get_secret_key::get_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal COUNTER_NOTE_LEN: Field = 4;\n\nstruct CounterNote {\n    owner: Field,\n    randomness: Field,\n    value: Field,\n    end: Field,\n    header: NoteHeader,\n}\n\nimpl CounterNote {\n    pub fn new(owner: Field, value: Field, end: Field) -> Self {\n        Self {\n            owner,\n            randomness: rand(),\n            value,\n            end,\n            header: NoteHeader::empty()\n        }\n    }\n\n    pub fn serialize(self) -> [Field; COUNTER_NOTE_LEN] {\n        [self.owner, self.randomness, self.value, self.end]\n    }\n\n    pub fn deserialize(serialized: [Field; COUNTER_NOTE_LEN]) -> Self {\n        Self {\n            owner: serialized[0],\n            randomness: serialized[1],\n            value: serialized[2],\n            end: serialized[3],\n            header: NoteHeader::empty()\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        pedersen_hash(self.serialize(), 0)\n    }\n\n    pub fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(CounterNoteMethods, self);\n        let secret = get_secret_key(self.owner);\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high\n        ], 0)\n    }\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            get_public_key(self.owner),\n            self.serialize()\n        );\n    }\n}\n\n\nfn deserialize(serialized: [Field; COUNTER_NOTE_LEN]) -> CounterNote {\n    CounterNote::deserialize(serialized)\n}\n\nfn serialize(note: CounterNote) -> [Field; COUNTER_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: CounterNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: CounterNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: CounterNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut CounterNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nfn broadcast(context: &mut PrivateContext, slot: Field, note: CounterNote) {\n    note.broadcast(context, slot)\n}\n\nglobal CounterNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast\n};",
        "path": "/home/jpag/Workground/aztec/statechannel/contracts/src/counter_note.nr"
      }
    }
  }
}