{"noir_version":"0.23.0+602f23f4fb698cf6e37071936a2a46593a998d08","name":"CounterStateChannel","functions":[{"name":"init_counter","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::abi::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"note_hash_tree_root","type":{"kind":"field"}},{"name":"nullifier_tree_root","type":{"kind":"field"}},{"name":"contract_tree_root","type":{"kind":"field"}},{"name":"l1_to_l2_message_tree_root","type":{"kind":"field"}},{"name":"archive_root","type":{"kind":"field"}},{"name":"public_data_tree_root","type":{"kind":"field"}},{"name":"global_variables_hash","type":{"kind":"field"}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"deployer_public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"constructor_vk_hash","type":{"kind":"field"}},{"name":"function_tree_root","type":{"kind":"field"}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::abi::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"start","type":{"kind":"field"},"visibility":"private"},{"name":"end","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"end":[{"start":24,"end":25}],"inputs":[{"start":0,"end":23}],"owner":[{"start":25,"end":26}],"start":[{"start":23,"end":24}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"note_hash_tree_root","type":{"kind":"field"}},{"name":"nullifier_tree_root","type":{"kind":"field"}},{"name":"contract_tree_root","type":{"kind":"field"}},{"name":"l1_to_l2_message_tree_root","type":{"kind":"field"}},{"name":"archive_root","type":{"kind":"field"}},{"name":"public_data_tree_root","type":{"kind":"field"}},{"name":"global_variables_hash","type":{"kind":"field"}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"deployer_public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"constructor_vk_hash","type":{"kind":"field"}},{"name":"function_tree_root","type":{"kind":"field"}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243]},"bytecode":"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","debug_symbols":"5VnLTiQxDPyXPiMUO3Zsz6+sOKBdVkJCsFq4If59uwfihCZ0a8JqmMcJkKrSZccpJ+Z5uHv4ef10+3D/OGyeBx42P56Hxz/X99Nfj0/Xf5+GTbgYbu5/jT9fLobft3c3w4bGXz/AMAR+Q2JAcbA2wZEogymAg4G1gYZgktcGCNHe4a8uhnSkumVvukk0gznqV3VrSzcw5W8ACy2rN8xhmqBDjXrU2EGpgfBlORBIyidoWZBJrkgIGFcWlgAZLFDKwOJWORytcjxa5fFolVNTuUnmIMCKcpSEGayR6g98BIumN6wmWYES5iMqxKlYI7TAHqRQMfQx6VOMfMAxpowVZl6OkV0wW5EgLe9nTwdzqY/0mo50GulIIR+YxFCnY4pRTiTG5Ecg2DxGPbuyFgi+rNRl3bBILXYayxGAyF3XATu/XEvOtYYwsxAMp5GOscVkrMbldCDnAomhrArb6kA4kXSYr0th5jaIpxGjcr46qek8xrjfGC25RwXTZeyqRSF9XbyWd7Hq2gahryxoVmd9UsMHpeY/XHnU/KH+7nnZVuMFWUGp1XqSP1oTVTf51JKQfFlMXA7oVAsfg0P3NhiLcgW8WlxyuAlkvxNUfaqZwIiWPbxetWt4grrfjKjkjFhdJ7zVYt+nRWdaYtivFmPXUh37dqWoP5uTBZx5RIRjFY77FQ5BzE8G6LL0COXMbceUSzaEaN48I6yAl564MZ5lSr7teRTpPPO98ESKfDIpAS0pWQNHH1gQV+HB66zxsj1Wp5iTQqmaclAmQQ8Je0ixh0Q9JO4hpR5S8+rGmDsKV8e/kLSHZB2k9ihh/O9WJpE0SNBDwh5SsyLG4Unux6EVE/WQuIfUrIjkfSBBoyLal/k1ku5M4svmh6K/1gnSzDVHjnZwrIPTtqI1EuxKQv3EVdh8fA2leTBkEvWQ2q6i7Delsknp7fK4+yaNHO3gWAdn902aSDtvUuRPbJJSrm+qBjSv7WwiaQ+pbZO+Salq9aOhX728/AM="},{"name":"increment_multiple","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::abi::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"note_hash_tree_root","type":{"kind":"field"}},{"name":"nullifier_tree_root","type":{"kind":"field"}},{"name":"contract_tree_root","type":{"kind":"field"}},{"name":"l1_to_l2_message_tree_root","type":{"kind":"field"}},{"name":"archive_root","type":{"kind":"field"}},{"name":"public_data_tree_root","type":{"kind":"field"}},{"name":"global_variables_hash","type":{"kind":"field"}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"deployer_public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"constructor_vk_hash","type":{"kind":"field"}},{"name":"function_tree_root","type":{"kind":"field"}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::abi::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"owner","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":23}],"owner":[{"start":23,"end":24}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"note_hash_tree_root","type":{"kind":"field"}},{"name":"nullifier_tree_root","type":{"kind":"field"}},{"name":"contract_tree_root","type":{"kind":"field"}},{"name":"l1_to_l2_message_tree_root","type":{"kind":"field"}},{"name":"archive_root","type":{"kind":"field"}},{"name":"public_data_tree_root","type":{"kind":"field"}},{"name":"global_variables_hash","type":{"kind":"field"}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"deployer_public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"constructor_vk_hash","type":{"kind":"field"}},{"name":"function_tree_root","type":{"kind":"field"}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340]},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"preimage","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"preimage":[{"start":3,"end":6}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[6,7,8,9]},"bytecode":"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","debug_symbols":"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"},{"name":"get_counter","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"owner":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[1,2,3]},"bytecode":"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","debug_symbols":"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S50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlK50tWelsyUpnS1Y6W7K6ZN62pbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdbZkrbMla50tWetsyfqSedu2zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LW2ZK1zpasdbZkrbMla50tWetsyVpnS9Y6W7LR2ZKNzpZsdLZko7Mlm0vmbTs6W7LR2ZKNzpZsdLZko7MlG50t2ehsyUZnSzY6W7LR2ZKNzpZsdLZko7MlG50t2ehsyUZnSzY6W7LR2ZKNzpZsdLZko7MlG50t2ehsyUZnSzY6W7LR2ZKNzpZsdLZko7MlG50t2ehsyUZnSzY6W7LR2ZKNzpZsdLZko7MlG50t2ehsyUZnSzY6W7LR2ZKNzpZsdLZko7MlG50t2ehsyUZnSzY6W7LR2ZKNzpZsdLZko7Ml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N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP8924mO++3Bm8c3gX8C7hXcG7hncD7xbewV4M9mKwF4O9GOzFYC8GezHYi8FeDPZisBeHvTjsxWEvDntx2IvDXhz24rAXh7047CVgLwF7CdhLwF4C9hKwl4C9BOwlYC8Be0nYS8JeEvaSsJeEvSTsJWEvCXtJ2EvCXgr2UrCXgr0U7KVgLwV7KdhLwV4K9lKwl4a9NOylYS8Ne2nYS8NeGvbSsJeGvTTsZWAvA3sZ2MvAXgb2MrCXgb0M7GVgLwN7WdjLwl4W9rKwl4W9LOxlYS8Le1nYy8JeDuzlwF4O7OXAXg7s5cBeDuzlwF4O7AX6rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36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"},{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::abi::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"note_hash_tree_root","type":{"kind":"field"}},{"name":"nullifier_tree_root","type":{"kind":"field"}},{"name":"contract_tree_root","type":{"kind":"field"}},{"name":"l1_to_l2_message_tree_root","type":{"kind":"field"}},{"name":"archive_root","type":{"kind":"field"}},{"name":"public_data_tree_root","type":{"kind":"field"}},{"name":"global_variables_hash","type":{"kind":"field"}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"deployer_public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"constructor_vk_hash","type":{"kind":"field"}},{"name":"function_tree_root","type":{"kind":"field"}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::abi::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":23}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"note_hash_tree_root","type":{"kind":"field"}},{"name":"nullifier_tree_root","type":{"kind":"field"}},{"name":"contract_tree_root","type":{"kind":"field"}},{"name":"l1_to_l2_message_tree_root","type":{"kind":"field"}},{"name":"archive_root","type":{"kind":"field"}},{"name":"public_data_tree_root","type":{"kind":"field"}},{"name":"global_variables_hash","type":{"kind":"field"}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"deployer_public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"constructor_vk_hash","type":{"kind":"field"}},{"name":"function_tree_root","type":{"kind":"field"}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212]},"bytecode":"H4sIAAAAAAAA/+Xd5XNUVxzG8U2yu6l7CU5wh9XsXdzdqtQLWzb1lir1UupOlXopdaeutLTUvcAfxPMMm5m8gFeczHDme2eeyUxe3NnP3rtXz/n9dqdSqR2pvUuT0qy0KO3d/udlRuNv7sCWfFrrSO9jvcVcR6lUrxTq+WJ+da5QrSXlXKlc60jySb6clNcUkmKxnpSSSrVWreSq+VKxnu8sV4udjRWnw33GXE+4M1pHpgfcmYPcndU6sj3gzgZ0d+33rd32+9R+9v8D/dxtgbdX19IceLuFNPeOxNwU0NwnEnNzQHPfSMwtAc39IjGnA5r7R2LOBDQPiMScDWgeGIm5NaB5UCTmtoDmdqB5MNA8BGgeCjQPA5qHA80jgOaRQPMooHk00DwGaB4LNI8DmscDzROA5olAcw5ozgPNBaC5CDSXgOYy0NwBNFeA5gRorgLNk4DmyUDzFKB5KtA8DWieDjTPAJpnAs2zgObZQPMcoHku0DwPaJ4PNC8AmhcCzYuA5sVA8xKgeSnQvAxoXg40rwCaTwKaTwaaTwGaTwWaTwOaTweaVwLNZwDNZwLNZwHNZwPN5wDN5wLN5wHN5wPNq4Dm1UBzDWi+AGheAzTXgeZOoPlCoPkioPlioPkSoPlSoPkyoPlyoPkKoPlKoHkt0HwV0Hw10HwN0Hwt0Hwd0Hw90LwOaL4BaL4RaL4JaL4ZaL4FaL4VaL4NaL4daF4PNN8BNG8Amu8Emu8Cmu8Gmu8Bmu8Fmu8Dmu8Hmh8Amh8Emh8Cmh8Gmh8Bmh8FmjcCzY8BzY8DzU8AzU8CzU8BzU8DzZuA5meA5meB5ueA5ueB5heA5heB5peA5peB5s1A8ytA8xag+VWg+TWg+XWg+Q2g+U2g+S2g+W2g+R2g+V2g+T2g+X2g+QOg+UOgeSvQ/BHQ/DHQ/AnQ/CnQ/BnQ/DnQ/AXQ/CXQ/BXQ/DXQ/A3Q/C3QvA1o/i4Sc2tA8/fA7bwdaP4BaP4RaN4BNP8ENP8cifmQgOZfIjEfGtD8ayTmwwKaf4vEfHhA8++RmI8IaP4jEvORAc1/RmI+KqD5r0jMRwc0/x2J+ZiA5n8iMR8b0PxvJObjApr/i8R8fEDz/5GYTwho3hmJ+cSA5l2RmHsFNO8OaG7rZm5quFuUtJJRsoqfX/q+0PdJvm/wdbSvK32d5esOn4d9XvJx2sct/469X3s79+q2/m2Nv72VPkpfpZ/SXxmgDFQGKe3KYGWIMlQZpgxXRigjlVHKaGWMMlYZp4xXJigT/Z0oeaXg71opKWWlQ6koiVJVJimTlSnKVGWaMr3x3c5UZimzlTnKXGWeMl9ZoCxUFimLlSXKUmWZslxZobj/vPuxuz+5+3W7f7X7Oa9U3O/X/W/dD9b9Ud0v1P0z3U/S/RVXKe6/V1Pcn839yty/y/2s3N/J/Y7c/8f9cNwfxv1S3D/E/TTcX2Kt4v4Drsfv+vSu1+765a7nvU5xvWfXP3Y9YNfHdb1Y1091PVHX11yvuP7iBsX1+VyvzvXbXM/M9b1c78r1n1wPyfWBXC/H9WNcT8X1RTYqrj/hegyuT+D5+p6/7vncmxTP9/X8V88H9fxIzxf0/DnPJ/P8qs2K599sUTw/w/MVPH7f49k9vtvjnT3+1+NhPT7U4yU9ftDj6Ty+bKvi8Ucej+PxKR6v4fELfp/v99t+3+v3n34f6Pdjfl/kfdPvE/x8fbvi569+Hunnc35e5ec3fp7h+3vf7/r+z/dDvj/w9bKvH3095esLn299/vHx2Mcn/167lj1HMZVAULsAAA==","debug_symbols":"q1bKyU9OLMnMzytWsqqurQUA"},{"name":"increment_single","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::abi::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"note_hash_tree_root","type":{"kind":"field"}},{"name":"nullifier_tree_root","type":{"kind":"field"}},{"name":"contract_tree_root","type":{"kind":"field"}},{"name":"l1_to_l2_message_tree_root","type":{"kind":"field"}},{"name":"archive_root","type":{"kind":"field"}},{"name":"public_data_tree_root","type":{"kind":"field"}},{"name":"global_variables_hash","type":{"kind":"field"}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"deployer_public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"constructor_vk_hash","type":{"kind":"field"}},{"name":"function_tree_root","type":{"kind":"field"}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::abi::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":23}],"owner":[{"start":23,"end":24}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"block_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"note_hash_tree_root","type":{"kind":"field"}},{"name":"nullifier_tree_root","type":{"kind":"field"}},{"name":"contract_tree_root","type":{"kind":"field"}},{"name":"l1_to_l2_message_tree_root","type":{"kind":"field"}},{"name":"archive_root","type":{"kind":"field"}},{"name":"public_data_tree_root","type":{"kind":"field"}},{"name":"global_variables_hash","type":{"kind":"field"}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"deployer_public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"constructor_vk_hash","type":{"kind":"field"}},{"name":"function_tree_root","type":{"kind":"field"}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348]},"bytecode":"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","debug_symbols":"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"}],"events":[],"file_map":{"18":{"source":"use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n","path":"std/grumpkin_scalar_mul.nr"},"28":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"39":{"source":"use dep::aztec::{\n    protocol_types::address::AztecAddress,\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        nullifier_key::get_nullifier_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal COUNTER_NOTE_LEN: Field = 3;\n\nstruct CounterNote {\n    owner: AztecAddress,\n    value: Field,\n    end: Field,\n    header: NoteHeader,\n}\n\nimpl CounterNote {\n    pub fn new(owner: AztecAddress, value: Field, end: Field) -> Self {\n        CounterNote {\n            owner,\n            value,\n            end,\n            header: NoteHeader::empty()\n        }\n    }\n\n    pub fn serialize(self) -> [Field; COUNTER_NOTE_LEN] {\n        [self.owner.to_field(), self.value, self.end]\n    }\n\n    pub fn deserialize(serialized: [Field; COUNTER_NOTE_LEN]) -> Self {\n        CounterNote {\n            owner: AztecAddress::from_field(serialized[0]),\n            value: serialized[1],\n            end: serialized[2],\n            header: NoteHeader::empty()\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        pedersen_hash(self.serialize(), 0)\n    }\n\n    pub fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(CounterNoteMethods, self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high\n        ], 0)\n    }\n\n    pub fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(CounterNoteMethods, self);\n        let secret = get_nullifier_secret_key(self.owner);\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high\n        ], 0)\n    }\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            get_public_key(self.owner),\n            self.serialize()\n        );\n    }\n}\n\nfn deserialize(serialized: [Field; COUNTER_NOTE_LEN]) -> CounterNote {\n    CounterNote::deserialize(serialized)\n}\n\nfn serialize(note: CounterNote) -> [Field; COUNTER_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: CounterNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: CounterNote, context: &mut PrivateContext) -> Field {\n    note.compute_nullifier(context)\n}\n\nfn compute_nullifier_without_context(note: CounterNote) -> Field {\n    note.compute_nullifier_without_context()\n}\n\nfn get_header(note: CounterNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut CounterNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nfn broadcast(context: &mut PrivateContext, slot: Field, note: CounterNote) {\n    note.broadcast(context, slot)\n}\n\nglobal CounterNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    compute_nullifier_without_context,\n    get_header,\n    set_header,\n    broadcast\n};\n","path":"/Users/ianbrighton/Documents/Mach34/aztec_sandbox/aztec-state-channels/contracts/counter_channel/src/counter_note.nr"},"40":{"source":"mod counter_note;\n\ncontract CounterStateChannel {\n    use dep::std::option::Option;\n    use dep::aztec::{\n        protocol_types::{\n            address::AztecAddress,\n            abis::function_selector::FunctionSelector\n        },\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::{\n            map::Map,\n            singleton::Singleton\n        },\n        log::emit_encrypted_log,\n        oracle::get_public_key::get_public_key,\n    };\n    use crate::counter_note::{CounterNote, CounterNoteMethods, COUNTER_NOTE_LEN};\n\n    struct Storage {\n        counters: Map<AztecAddress, Singleton<CounterNote, COUNTER_NOTE_LEN>>,\n    }\n\n    impl Storage {\n        fn init(context: Context) -> Self {\n            Storage {\n                counters: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        Singleton::new(context, slot, CounterNoteMethods)\n                    },\n                ),\n            }\n        }\n    }\n\n    #[aztec(private)]\n    fn constructor() {}\n\n    /**\n     * Initialize a new counter for a given user\n     * @notice: mocks staking to start a new channel\n     * \n     * @param start - the value to start the counter at\n     * @param end - the value to conclude the counter at\n     */\n    #[aztec(private)]\n    fn init_counter(start: Field, end: Field, owner: AztecAddress) {\n        // get the singleton from storage\n        let counter_singleton = storage.counters.at(owner);\n        // check to see if the counter has already been initialized\n        // unreachable since unconstrained :( how to check if initialized???\n        // assert(\n        //     counter_singleton.is_initialized(Option::some((owner))) == false,\n        //     \"Counter has already been initialized for this account\"\n        // );\n        // // initialize a new singleton for the counter\n        counter_singleton.initialize(\n            &mut CounterNote::new(owner, start, end),\n            Option::some(owner),\n            true\n        );\n    }\n\n    /**\n     * Increment the counter once (testing util)\n     */\n    #[aztec(private)]\n    fn increment_single(owner: AztecAddress) {\n        // get the singleton from storage\n        let counter_singleton = storage.counters.at(owner);\n        // check that the counter can be incremented\n        let mut counter = counter_singleton.get_note(true);\n        assert(\n            counter.value as u120 < counter.end as u120, \"Counter has already been incremented to its end value\"\n        );\n        // increment value in note and replace in storage\n        counter.value += 1;\n        counter_singleton.replace(&mut counter, false);\n        // @todo: publicly mark counter as complete if start == end\n    }\n\n    /**\n     * Increment the counter recursively until it reaches the end value\n     * @notice: DO NOT INCREMENT MORE THAN 64 TIMES (current call stack limit)\n     */\n    #[aztec(private)]\n    fn increment_multiple(owner: Field) {\n        let from = AztecAddress::from_field(owner);\n        // get the singleton from storage\n        let counter_singleton = storage.counters.at(from);\n        // get the counter note from storage\n        let mut counter = counter_singleton.get_note(true);\n\n        // increment value in note and replace in storage\n        counter.value += 1;\n        counter_singleton.replace(&mut counter, true);\n        // if the counter has not reached its end value, increment again\n        // if counter.value as u120 < counter.end as u120 {\n        //     context.call_private_function(\n        //         context.this_address(),\n        //         FunctionSelector::from_signature(\"increment_multiple(Field)\"),\n        //         [owner]\n        //     );\n        // }\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub [Field; 3] {\n        let note = storage.counters.at(owner).view_note();\n        [note.owner.to_field(), note.value, note.end]\n    }\n\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: AztecAddress,\n        nonce: Field,\n        storage_slot: Field,\n        preimage: [Field; COUNTER_NOTE_LEN]\n    ) -> pub [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(CounterNoteMethods, note_header, preimage)\n    }\n}\n","path":"/Users/ianbrighton/Documents/Mach34/aztec_sandbox/aztec-state-channels/contracts/counter_channel/src/main.nr"},"41":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    grumpkin_point::GrumpkinPoint,\n};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/log.nr"},"44":{"source":"use dep::std::option::Option;\nuse dep::protocol_types::constants::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/note/note_getter.nr"},"45":{"source":"use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = 0;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note, context);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/note/lifecycle.nr"},"46":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__OUTER_NULLIFIER,\n    hash::pedersen_hash,\n};\nuse crate::{\n    context::PrivateContext,\n    note::{\n        note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_inner_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note_with_header, context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier_without_context = note_interface.compute_nullifier_without_context;\n    let inner_nullifier = compute_nullifier_without_context(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/note/utils.nr"},"48":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n    },\n    hash::pedersen_hash,\n};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/note/note_hash.nr"},"51":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/types/vec.nr"},"61":{"source":"use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nuse dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(_storage_slot: Field, _serialized_note: [Field; N], _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(storage_slot: Field, serialized_note: [Field; N], inner_note_hash: Field) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS] // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/notes.nr"},"64":{"source":"use dep::protocol_types::{\n    address::{\n        AztecAddress,\n        PartialAddress,\n    },\n    grumpkin_point::GrumpkinPoint,\n};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(pub_key, partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/get_public_key.nr"},"69":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::NUM_FIELDS_PER_SHA256,\n    grumpkin_point::GrumpkinPoint,\n};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(contract_address, storage_slot, encryption_pub_key, preimage), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: AztecAddress, _event_selector: Field, _message: T) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/logs.nr"},"74":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::grumpkin_scalar::GrumpkinScalar;\n\nstruct KeyPair {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinScalar,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> KeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    KeyPair {\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinScalar { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> KeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinScalar {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/oracle/nullifier_key.nr"},"78":{"source":"use crate::oracle::get_public_key::get_public_key;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::{\n    grumpkin_scalar::GrumpkinScalar,\n    grumpkin_scalar_mul::grumpkin_fixed_base,\n};\n\npub fn validate_nullifier_key_against_address(\n    address: AztecAddress,\n    nullifier_public_key: GrumpkinPoint,\n    nullifier_secret_key: GrumpkinScalar\n) {\n    // TODO: Nullifier public key should be part of the address.\n    // Validation of the secret key should happen in the kernel circuit.\n    let owner_public_key = get_public_key(address);\n    assert(owner_public_key.x == nullifier_public_key.x);\n    assert(owner_public_key.y == nullifier_public_key.y);\n    let computed_public_key = grumpkin_fixed_base(nullifier_secret_key);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/key/nullifier_key.nr"},"80":{"source":"use dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n    },\n    contrakt::deployment_data::ContractDeploymentData,\n    hash::hash_args,\n};\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/abi.nr"},"81":{"source":"use crate::{\n    abi::{\n        PrivateContextInputs,\n        PublicContextInputs,\n    },\n    key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        call_private_function::call_private_function_internal,\n        public_call::call_public_function_internal,\n        enqueue_public_function_call::enqueue_public_function_call_internal,\n        context::get_portal_address,\n        get_block_header::get_block_header,\n        nullifier_key::get_nullifier_key_pair,\n    },\n    types::vec::BoundedVec,\n    utils::Reader,\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_data::FunctionData,\n        function_selector::FunctionSelector,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        call_stack_item::PrivateCallStackItem,\n        call_stack_item::PublicCallStackItem,\n        side_effect::{SideEffect, SideEffectLinkedToNoteHash},\n    },\n    address::{\n        AztecAddress,\n        EthAddress,\n    },\n    constants::{\n        MAX_NEW_COMMITMENTS_PER_CALL,\n        MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NEW_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n        MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_PUBLIC_DATA_READS_PER_CALL,\n        MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n        MAX_READ_REQUESTS_PER_CALL,\n        NUM_FIELDS_PER_SHA256,\n        RETURN_VALUES_LENGTH,\n    },\n    contrakt::{\n        deployment_data::ContractDeploymentData,\n        storage_read::StorageRead,\n        storage_update_request::StorageUpdateRequest,\n    },\n    hash::hash_args,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::{\n    grumpkin_scalar::GrumpkinScalar,\n    option::Option,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(SideEffect::empty()),\n\n            new_commitments: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n\n            block_header: inputs.block_header,\n\n            private_call_stack_hashes: BoundedVec::new(0),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: u32) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect {\n            value: read_request,\n            counter: self.side_effect_counter,\n        };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect {\n            value: note_hash,\n            counter: self.side_effect_counter,\n        };\n        self.new_commitments.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: nullified_commitment,\n            counter: self.side_effect_counter,\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinScalar {\n        let key_pair = get_nullifier_key_pair(account);\n        validate_nullifier_key_against_address(account, key_pair.public_key, key_pair.secret_key);\n        // TODO: Add request to context.\n        // self.context.push_nullifier_key_validation_request(public_key, secret_key);\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_message_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address,\n            function_selector, \n            args_hash,\n            self.side_effect_counter,\n        );\n        let mut reader = Reader::new(fields);\n\n        let item = PrivateCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: FunctionData {\n                selector: FunctionSelector::from_field(reader.read()),\n                is_internal: reader.read() as bool,\n                is_private: reader.read() as bool,\n                is_constructor: reader.read() as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : AztecAddress::from_field(reader.read()),\n                    storage_contract_address : AztecAddress::from_field(reader.read()),\n                    portal_contract_address : EthAddress::from_field(reader.read()),\n                    function_selector: FunctionSelector::from_field(reader.read()), // practically same as fields[1]\n                    is_delegate_call : reader.read() as bool,\n                    is_static_call : reader.read() as bool,\n                    is_contract_deployment: reader.read() as bool,\n                    start_side_effect_counter: reader.read() as u32,\n                },\n                args_hash: reader.read(),\n                return_values: reader.read_array([0; RETURN_VALUES_LENGTH]), // +1\n                read_requests: reader.read_struct_array(SideEffect::deserialise, [SideEffect::empty(); MAX_READ_REQUESTS_PER_CALL]),\n                new_commitments: reader.read_struct_array(SideEffect::deserialise, [SideEffect::empty(); MAX_NEW_COMMITMENTS_PER_CALL]),\n                new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialise, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n                private_call_stack_hashes: reader.read_array([0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n                public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n                new_l2_to_l1_msgs: reader.read_array([0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n                end_side_effect_counter: reader.read() as u32,\n                encrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n                unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n                encrypted_log_preimages_length: reader.read(),\n                unencrypted_log_preimages_length: reader.read(),\n                block_header: BlockHeader{\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : reader.read(),\n                    nullifier_tree_root : reader.read(),\n                    contract_tree_root : reader.read(),\n                    l1_to_l2_message_tree_root : reader.read(),\n                    archive_root : reader.read(),\n                    public_data_tree_root: reader.read(),\n                    global_variables_hash: reader.read(),\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: GrumpkinPoint {\n                      x: reader.read(), \n                      y: reader.read()\n                    },\n                    constructor_vk_hash : reader.read(),\n                    function_tree_root : reader.read(),\n                    contract_address_salt : reader.read(),\n                    portal_contract_address : EthAddress::from_field(reader.read()),\n                },\n                chain_id: reader.read(),\n                version: reader.read(),\n            },\n            is_execution_request: reader.read() as bool,\n        };\n\n        reader.finish();\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n        \n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address));\n        assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n            self.side_effect_counter\n        );\n\n        let mut reader = Reader::new(fields);\n\n        let item = PublicCallStackItem {\n            contract_address:  AztecAddress::from_field(reader.read()),\n            function_data: FunctionData {\n                selector: FunctionSelector::from_field(reader.read()),\n                is_internal: reader.read() as bool,\n                is_private: reader.read() as bool,\n                is_constructor: reader.read() as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : AztecAddress::from_field(reader.read()),\n                    storage_contract_address : AztecAddress::from_field(reader.read()),\n                    portal_contract_address : EthAddress::from_field(reader.read()),\n                    function_selector: FunctionSelector::from_field(reader.read()), // practically same as fields[1]\n                    is_delegate_call : reader.read() as bool,\n                    is_static_call : reader.read() as bool,\n                    is_contract_deployment: reader.read() as bool,\n                    start_side_effect_counter: reader.read() as u32,\n                },\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [SideEffect::empty(); MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: AztecAddress::zero(),\n            },\n            is_execution_request: true,\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address));\n        assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: AztecAddress,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = StorageRead::empty();\n        let empty_storage_update = StorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_reads: BoundedVec::new(empty_storage_read),\n            public_call_stack_hashes: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: AztecAddress::zero(),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect {\n            value: note_hash,\n            counter: self.side_effect_counter\n        };\n        self.new_commitments.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_message_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress, \n        function_selector: FunctionSelector,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/context.nr"},"82":{"source":"pub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\n// TODO(#3470): Copied over from https://github.com/AztecProtocol/aztec-packages/blob/a07c4bd47313be6aa604a63f37857eb0136b41ba/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/base/base_rollup_inputs.nr#L599\n// move to a shared place?\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\nstruct Reader<N> {\n    data: [Field; N],\n    offset: Field,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    } \n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/utils.nr"},"93":{"source":"use dep::std::option::Option;\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n    },\n    hash::pedersen_hash,\n};\n\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    nullifier_key::get_nullifier_secret_key,\n    notes::check_nullifier_exists,\n};\n\npub fn compute_singleton_initialization_nullifier(\n    storage_slot: Field,\n    owner: Option<AztecAddress>,\n    context: Option<&mut PrivateContext>\n) -> Field {\n    if owner.is_some() {\n        let secret = if context.is_some() {\n            context.unwrap_unchecked().request_nullifier_secret_key(owner.unwrap_unchecked())\n        } else {\n            get_nullifier_secret_key(owner.unwrap_unchecked())\n        };\n        pedersen_hash(\n            [storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    } else {\n        pedersen_hash([storage_slot], GENERATOR_INDEX__INITIALIZATION_NULLIFIER)\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<AztecAddress>, Option<&mut PrivateContext>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<AztecAddress>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner, Option::none());\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note,\n        owner: Option<AztecAddress>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner, self.context);\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, self.note_interface, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(\n        self,\n        new_note: &mut Note,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self, broadcast: bool) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/state_vars/singleton.nr"},"94":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{\n    hash::pedersen_hash,\n    traits::{ToField}\n};\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/aztec-nr/aztec/src/state_vars/map.nr"},"135":{"source":"use crate::{\n    constants::{\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n    },\n    hash::pedersen_hash,\n    utils,\n    grumpkin_point::GrumpkinPoint,\n};\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, ToField};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(pub_key: GrumpkinPoint, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_key.x, pub_key.y, partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n    \n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n\n    pub fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n\n    pub fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl EthAddress{\n    pub fn zero() -> Self {\n        Self {\n            inner: 0\n        }\n    }\n\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs : Self, rhs : Self) -> Self{\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self {\n            inner : result\n        }\n    }\n\n    pub fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n\n    pub fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0]\n        }\n    }\n}\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field : Field) -> Self {\n        Self {\n            inner : field\n        }\n    }\n\n    pub fn compute(contract_address_salt : Field, function_tree_root : Field, constructor_hash : Field) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash([\n                // TODO why the zeroes?\n                0,\n                0,\n                contract_address_salt,\n                function_tree_root,\n                constructor_hash\n            ], GENERATOR_INDEX__PARTIAL_ADDRESS)\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/noir-protocol-circuits/src/crates/types/src/address.nr"},"158":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::utils::bounded_vec::BoundedVec;\nuse crate::constants::{\n        ARGS_HASH_CHUNK_COUNT,\n        ARGS_HASH_CHUNK_LENGTH,\n        CONTRACT_TREE_HEIGHT, \n        FUNCTION_TREE_HEIGHT, \n        NOTE_HASH_TREE_HEIGHT,\n        NUM_FIELDS_PER_SHA256,\n        GENERATOR_INDEX__SILOED_COMMITMENT,\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK,\n        GENERATOR_INDEX__CONSTRUCTOR,\n        GENERATOR_INDEX__PARTIAL_ADDRESS,\n        GENERATOR_INDEX__CONTRACT_ADDRESS,\n        GENERATOR_INDEX__COMMITMENT_NONCE,\n        GENERATOR_INDEX__UNIQUE_COMMITMENT,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    function_tree_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, function_tree_root };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n","path":"/Users/ianbrighton/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.20.0/yarn-project/noir-protocol-circuits/src/crates/types/src/hash.nr"}}}