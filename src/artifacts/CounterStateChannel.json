{
  "name": "CounterStateChannel",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+XdZZOTZxSH8V0gSd27uLu1ySbZJFVK3alSL6Rk6y1V6qXU3XB390/IuWbCwAt4xb0z3HNl5j9590x+m+yj5z7nZE9Pz7aeM6/e7vuC7nv5wl6VQmyjcI7tVssDtVqn0d+pVCtLy/2tdrNertXbA81Ks1Jv1pf1N6vVTrPWbLTarUa5ValVO5XBeqs62N1wId1nLA+FuxjbKA6Bu3iRu0uxjdIQuEuJ3ef7vV/o5xw5RJ9zWOLvqTeheVQm5mEJzaMzMQ9PaB6TiXlEQvPYTMyFhOZxmZiLCc3jMzGXEponZGIemdA8UWieJDRPFpqnCM1TheZpQvN0oXmG0DxTaJ4lNM8WmucIzXOF5nlC83yh+Sah+WahuSw0V4TmfqG5KjTXhOa60DwgNDeE5qbQ3BKabxGabxWabxOabxea7xCa7xSaFwjNdwnNC4Xmu4Xme4Tme4Xm+4Tm+4XmB4TmB4Xmh4Tmh4XmR4TmR4Xmx4Tmx4XmRULzE0Lzk0LzU0Lz00LzM0Lzs0LzYqH5OaH5eaH5BaH5RaH5JaH5ZaH5FaH5VaF5idC8VGhuC82vCc3LhOaO0DwoNL8uNL8hNL8pNL8lNL8tNL8jNL8rNL8nNL8vNC8Xmj8Qmj8Umj8Smj8Wmj8Rmj8VmlcIzZ8JzZ8LzV8IzV8KzV8JzV8Lzd8Izd8KzSuF5u+E5lVC8/dC8w9C849C809C889C8y9C869C829C8+9C8x9C859C819C899C8z9C879C839C8/9C82qheY3QvFZoXic0rxeaNwjNG4XmTULzZqF5i9C8VWjeJjRvF5p3CM07heZdmZgvSWjenYn50oTmPZmYL0to3puJ+fKE5n2ZmK9IaN6fifnKhOYDmZivSmg+mIn56oTmQ5mYr0loPpyJ+dqE5iOZmK9LaD6aifn6hOZjmZhvSGg+non5xoTmE5mY+xKaTyY093W309s1D4+MiBQixUgpwjUh10hcM3AOzTkl51icc3AM5pjEPpp9Fv/D/Kb5jvvO+ntu6r6PioyOjImMjYyLjI9MiEyMTIpMjkyJTI1Mi0yPzIjMjMyKzI7MicyNzIvMjzDjnpnvfInMBGdGNjOjmaHMTGFm7DYizGBlJikzOplZyQxHZhoy4+/0zDtmoi2MMDOLGVLMVGLGEDN3mEHDTBZmlDCzgxkWzHRgxgE9/xdF6AlPj3R6htNDm57S9FheHKEHLz1p6dFKz1J6eNLTkh6P9DxcEqEnXjtCzzR6iNFTix5T9FyiBxE9eehRQ88WepjQ04MeF/R8WB6hJwBr5Fkzzhpq1hSzxnZFhDWYrElkjR5r1ljDxZom1viw5mVlhDURqyLUzFNDTk01NcbU3FKDSk0mNYrU7FHDRk0XNU7U/FADQ00INRLUDPAMnWfKPGPlmSPP4HgmxTMafhPcw+eeNvd4uee5PcI9Me4Rcc+EewhcU3ONyTUX1yCck3OOyjkb5zAc0znGsc9nH8g+gf+R069TXMw0LzyaAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_counter",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "increment_multiple",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "increment_single",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "init_counter",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "start",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "end",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJzt3d2O5La1huF7mWMj0PohKfpWghwYeydAgMDZ2PaZMfceGRlV9ySS6THZxbdIHsUIqqcWF6c+LXH6Kf3y6R///J8ffv77P3/86dP3v3za/iTh0/d//uXTT//3w4+//h8//fzD///86fvtu09//fF/j//9/N2nv/39H3/99L18/u6/XqXuQb688vjvGB6vzn7xcknpfPH29gebff7Ld78WEimFJEohO6WQDClEN0ohQilEKYUYpRCnFEJJVqUkq1KSVSnJqpRkNUqyGiVZjZKsRklWoySrUZLVKMlqlGQ1SrIaJVmdkqxOSVanJKtTktUpyeqUZHVKsjolWZ2SrE5J1kBJ1kBJ1kBJ1kBJ1kBJ1kBJ1kBJ1kBJ1kBJ1kBJ1khJ1khJ1khJ1khJ1khJ1khJ1khJ1khJ1khJ1khJ1kRJ1kRJ1kRJ1kRJ1kRJ1kRJ1kRJ1kRJ1kRJ1kRJ1p2SrDslWXdKsu6UZN0pybpTknWnJOtOSdadkqw7JVkzJVkzJVkzJVkzJVkzJVkzJVkzJVkzJVkzJVkzJVllo0SrbJRslY0SrrJR0lU2SrzKRslX2SgBKxslYWWjRKxsmIwVTMYKJmMFk7GCyVjBZCzHZHFQFkdlcVgWxmUJBmYJRmYJhmYJxmYJBmcJRmcJhmcJxmcJBmgJRmgJhmgJxmgJBmkJRmkJhmkJxmkJBmoJRmoJhmoJxmoJBmsJRmsJhmsJxmsJBmwJRmwJhmwJxmwJBm0JRm0Jhm0Jxm0JBm4JRm4Jhm4Jxm4JBm8JRm8Jhm8Jxm8JBnAJRnAJhnAJxnAJBnEJRnEJhnEJxnEJBnIJRnIJhnIJxnIJBnMJRnMJhnMJxnMJBnQJRnQJhnQJxnQJBnUJRnUJhnUJxnUJBnYJRnYJhnYJxnYJBncJRncJhncJxncJBngJRngJhngJxngJBnkJRnkJhnkJxnkpxnkpxnkpxnkpxnnpRslYxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvxTgvwzgvwzgvwzgvwzgv2ygZaxjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjnZRjn5Rjn5Rjn5Rjn5Rjn5RslYx3jvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvALGeQWM8woY5xUwzitslIwNGOcVMM4rYJxXwDivgHFeAeO8AsZ5BYzzChjnFTDOK2CcV8A4r4BxXgHjvALGeQWM8woY5xUwzitgnFfAOK+AcV4B47wCxnkFjPMKGOcVMM4rYJxXwDivgHFeAeO8AsZ5BYzzChjnFTDOK2CcV8A4r4BxXgHjvALGeQWM8woY5xUwzitgnFfAOK+AcV4B47wCxnkFjPMKGOcVMM4rYJxXwDivgHFeAeO8AsZ5BYzzChjnFTDOK2CcV8A4r4BxXgHjvALGeQWM8woY5xUwzitgnFfAOK+AcV4B47wCxnkFjPMKGOcVMM4rYJxXwDivgHFeAeO8AsZ5BYzzChjnFTDOK2CcV8A4r4BxXgHjvALGeQWM8woY5xUwzitgnFfAOK+AcV4B47wCxnlFjPOKGOcVMc4rYpxX3CgZGzHOK2KcV8Q4r4hxXhHjvCLGeUWM84oY5xUxzitinFfEOK+IcV4R47wixnlFjPOKGOcVMc4rYpxXxDiviHFeEeO8IsZ5RYzzihjnFTHOK2KcV8Q4r4hxXhHjvCLGeUWM84oY5xUxzitinFfEOK+IcV4R47wixnlFjPOKGOcVMc4rYpxXxDiviHFeEeO8IsZ5RYzzihjnFTHOK2KcV8Q4r4hxXhHjvCLGeUWM84oY5xUxzitinFfEOK+IcV4R47wixnlFjPOKGOcVMc4rYpxXxDiviHFeEeO8IsZ5RYzzihjnFTHOK2KcV8Q4r4hxXhHjvCLGeUWM84oY5xUxzitinFfEOK+IcV4R47wixnlFjPOKGOcVMc4rYpxXxDiviHFeEeO8IsZ5RYzzShjnlTDOK2GcV8I4r7RRMjZhnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rVTqvfX9UEjatq6QuY1tWUpexLSupy9iWldRlbMtK6jK2ZSV1GduykrqMbVlJXcY2rKTSebWsBJOxlc6rZSWYjK10Xi0rwWRspfNqWQkmYyudV8tKMBlb6bxaVoLJ2Ern1bISTMZWOq+WlWAyttJ5tawEk7GVzqtlJZiMrXReLSvBZGyl82pZCSZjK51Xy0owGVvpvFpWgsnYSufVshJKxu6VzqtlJZSM3SudV8tKKBm7b5SM3SudV8tKKBm7VzqvlpVQMnavdF4NK6l0Xi0rwWRspfNqWQkmYyudV8tKMBlb6bxaVoLJ2Ern1bISTMZWOq+WlWAyttJ5tawEk7GVzqtlJZiMrXReLSvBZGyl82pZCSZjK51Xy0owGVvpvFpWgsnYSufVshJMxlY6r5aVYDK20nm1rASTsZXOq2UlmIytdF4tK8FkbKXzalkJJmMrnVfLSjAZW+m8WlaCydhK59WyEkzGVjqvlpVgMrbSebWsBJOxlc6rZSWYjK10Xi0rwWRspfNqWQkmYzHOa8c4rx3jvHaM89oxzmvHOK8d47x2jPPaMc5rxzivHeO8dozz2jHOa8c4rx3jvHaM89oxzmvHOK8d47x2jPPaMc5rxzivHeO8dozz2jHOa8c4rx3jvHaM89oxzmvHOK8d47x2jPPaMc5rxzivHeO8dozz2jHOa8c4r4xxXhnjvDLGeWWM88obJWMzxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV6yYaDXUQolZY9SKDF7lELJ2aMUStAepVCS9iiFErVHKZSsPUqhhO1RCidtMeTrKIWTthj0dZTCSVsM+zpK4aQtBn4dpXDSFkO/jlI4aYvBX0cpnLTF8K+jFE7aYgDYUQonbTEE7CiFk7YYBHaUwklbDAM7SuGkLQaCHaVw0hZDwY5SOGmLwWBHKZy0xXCwoxRO2mJA2FEKJ20xJOwohZO2GBR2lMJJWwwLO0rhpC0Ghh2lcNIWQ8OOUjhpi8FhRymctMXwsKMUTtpigNhRCidtMUTsKIWTthgkdpTCSVsMEztK4aQtBoodpXDSFkPFjlI4aYvBYkcpnLTFcLGjFE7aYsDYUQonbTFk7CiFk7YYNHaUwklbDBs7SuGkLQaOHaVw0hZDx45SOGmLwWNHKZy0xfCxoxRO2mIA2VEKJ20xhOwohZO2GER2lMJJWwwjO0rhpC0Gkh2lcNIWQ8mOUjBpKxxLJhxLJhxLJhxLJhsmbYVjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyYRjyZRjyZRjyZRjyZRjyXTDpK1yLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlyLJlxLJlxLJlxLJlxLJltmLQ1jiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUzjiUz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",
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "eJzN3d+OJdtx3OF3OdeEsTNXrn98FcMXhC0DAgTKMHkn8N1VhM/umWPmYmX/Tqk7riQBE6ytmag1w68qdv/HL//27//zT3/913//819++eN//PL6b/OXP/73//jlL//nT3/++//9l7/+6f/+9Zc/vv7wy7/8+X9d//Nvf/jlf//rv/3LL3+0v/3hH36VR6z166/06C//+NU7kl9uc75/8evHf3Brf/sff7g+xxL5HFvkc9hL5YOYygdxlQ/SVD5IqHyQrvJBhsoHUTlXTeVgNZWT1VVOVlc5WV3lZHWVk9VVTlZXOVld5WR1lZPVVU5WVzlZm8rJ2lRO1qZysjaVk7WpnKxN5WRtKidrUzlZm8rJ2lRO1lA5WUPlZA2VkzVUTtZQOVlD5WQNlZM1VE7WUDlZQ+Vk7Sona1c5WbvKydpVTtaucrJ2lZO1q5ysXeVk7Sona1c5WYfKyTpUTtahcrIOlZN1qJysQ+VkHSon61A5WYfKyTpUTtapcrJOlZN1qpysU+VknSon61Q5WafKyTpVTtapcrJOlZN1qZysS+VkXSon61I5WZfKybpUTtalcrIulZN1qZysS+Vk3Son61Y5WbfKybpVTtatcrJulZN1q5ysW+Vk3Son61Y5We2lcrTaS+VstZfK4WovldPVXirHq71Uzld7qRyw9lI5Ye2lcsTaS+aMFZpjyZyxOoMsnUWWziRLZ5OlM8rSWWXpzLJkdlkmM8wymWWWyUyzTGabZTLjLJNZZ5nMPMtk9lkmM9AymYWWyUy0TGajZTIjLZNZaZnMTMtkdlomM9QymaWWyUy1TGarZTJjLZNZa5nMXMtk9lomM9gymcWWyUy2TGazZTKjLZNZbZnMbMtkdlsmM9wymeWWyUy3TGa7ZTLjLZNZb5nMfMtk9lsmM+AymQWXyUy4TGbDZTIjLpNZcZnMjMtkdlwmM+QymSWXyUy5TGbLZTJjLpNZc5nMnMtk9lwmM+gymUWXyUy6TGbTZTKjLpNZdZnMrMtkdl0mM+wymWWXyUy7TGbbZTLjLpNZd5nMvMtk9l0mM/AymYWXyUy8TGbjZTIjL5NZeZnMzMtkdl4us/NymZ2Xy+y8XGbn5S+VM9Zldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZeTWZnVeT2Xk1mZ1Xk9l5tZfKGdtkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2Xk1m59Vkdl5NZufVZHZeTWbn1WR2XiGz8wqZnVfI7LxCZucVL5UzNmR2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5dZmdV5fZeXWZnVeX2Xn1l8oZ22V2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeXWbn1WV2Xl1m59Vldl5dZufVZXZeQ2bnNWR2XkNm5zVkdl7jpXLGDpmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XlNl5TZmd15TZeU2Zndd8qZyxU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm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yJ0acqeG3Kkhd2rInRpyp4bcqSF3asidGnKnhtypIXdqyJ0acqeG3Kkhd2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiDGvKghjyoIQ9qyIMa8qCGPKghD2rIgxryoIY8qCEPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyJMa8qSGPKkhT2rIkxrypIY8qSFPasiTGvKkhjypIU9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rIixryooa8qCEvasiLGvKihryoIS9qyIsa8qKGvKghL2rImxrypoa8qSFvasibGvKmhrypIW9qyJsa8qaGvKkh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"
    ],
    "fileMap": {
      "1": {
        "source": "mod counter_note;\n\ncontract CounterStateChannel {\n    use dep::std::option::Option;\n    use dep::aztec::{\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::{\n            map::Map,\n            singleton::Singleton\n        },\n        selector::compute_selector,\n        log::emit_encrypted_log,\n        oracle::get_public_key::get_public_key,\n    };\n    use crate::counter_note::{CounterNote, CounterNoteMethods, COUNTER_NOTE_LEN};\n\n    struct Storage {\n        counters: Map<Singleton<CounterNote, COUNTER_NOTE_LEN>>,\n    }\n\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                counters: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        Singleton::new(context, slot, CounterNoteMethods)\n                    },\n                ),\n            }\n        }\n    }\n\n    #[aztec(private)]\n    fn constructor() { }\n\n    /**\n     * Initialize a new counter for a given user\n     * @notice: mocks staking to start a new channel\n     * \n     * @param start - the value to start the counter at\n     * @param end - the value to conclude the counter at\n     */\n    #[aztec(private)]\n    fn init_counter(start: Field, end: Field, owner: Field) {\n        // get the singleton from storage\n        let counter_singleton =  storage.counters.at(owner);\n        // check to see if the counter has already been initialized\n        // unreachable since unconstrained :( how to check if initialized???\n        // assert(\n        //     counter_singleton.is_initialized(Option::some((owner))) == false,\n        //     \"Counter has already been initialized for this account\"\n        // );\n        // // initialize a new singleton for the counter\n        counter_singleton.initialize(\n            &mut CounterNote::new(owner, start, end),\n            Option::some(owner),\n            true\n        );\n    }\n\n    /**\n     * Increment the counter once (testing util)\n     */\n    #[aztec(private)]\n    fn increment_single(owner: Field) {\n        // get the singleton from storage\n        let counter_singleton = storage.counters.at(owner);\n        // check that the counter can be incremented\n        let mut counter = counter_singleton.get_note(true);\n        assert(\n            counter.value as u120 < counter.end as u120,\n            \"Counter has already been incremented to its end value\"\n        );\n        // increment value in note and replace in storage\n        counter.value += 1;\n        counter_singleton.replace(&mut counter, true);\n\n        // @todo: publicly mark counter as complete if start == end\n    }\n\n    /**\n     * Increment the counter recursively until it reaches the end value\n     * @notice: DO NOT INCREMENT MORE THAN 64 TIMES (current call stack limit)\n     */\n    #[aztec(private)]\n    fn increment_multiple(owner: Field) {\n        // get the singleton from storage\n        let counter_singleton = storage.counters.at(owner);\n        // get the counter note from storage\n        let mut counter = counter_singleton.get_note(true);\n\n        // increment value in note and replace in storage\n        counter.value += 1;\n        counter_singleton.replace(&mut counter, true);\n\n        // if the counter has not reached its end value, increment again\n        if counter.value as u120 < counter.end as u120 {\n            context.call_private_function(\n                context.this_address(),\n                compute_selector(\"increment_multiple(Field)\"),\n                [owner]\n            );\n        }\n    }\n\n    unconstrained fn get_counter(owner: Field) -> [Field; 3] {\n        let note = storage.counters.at(owner).view_note();\n        [note.owner, note.value, note.end]\n\n    }\n\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; COUNTER_NOTE_LEN]) -> [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(CounterNoteMethods, note_header, preimage)\n    }\n}\n",
        "path": "/home/jpag/Workground/aztec/statechannel/contracts/counter_channel/src/main.nr"
      },
      "17": {
        "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    pub fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\npub fn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\npub fn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
        "path": "std/grumpkin_scalar.nr"
      },
      "18": {
        "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
        "path": "std/grumpkin_scalar_mul.nr"
      },
      "33": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "92": {
        "source": "use dep::protocol_types::constants::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    BLOCK_HEADER_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__BLOCK_HASH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:block-header\nstruct BlockHeader {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    archive_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:block-header\n\nimpl BlockHeader {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; BLOCK_HEADER_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.archive_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn deserialize(deserialized: [Field; BLOCK_HEADER_LENGTH]) -> Self {\n        BlockHeader {\n            note_hash_tree_root: deserialized[0],\n            nullifier_tree_root: deserialized[1],\n            contract_tree_root: deserialized[2],\n            l1_to_l2_messages_tree_root: deserialized[3],\n            archive_root: deserialized[4],\n            public_data_tree_root: deserialized[5],\n            global_variables_hash: deserialized[6],\n        }\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, archive_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n\n    pub fn block_hash(self) -> Field {\n        // TODO(#3442): Unify the ordering in `BlockHeader::serialize` function and the ordering\n        // in the block hash preimage --> This requires changes in the circuits.\n        let inputs = [\n            self.global_variables_hash,\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.public_data_tree_root\n        ];\n        pedersen_hash(inputs, GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_header.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "93": {
        "source": "use dep::protocol_types::constants::GENERATOR_INDEX__CONTRACT_ADDRESS;\nuse crate::hash::pedersen_hash;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n    pedersen_hash([pub_key_x, pub_key_y, partial_address],\n        GENERATOR_INDEX__CONTRACT_ADDRESS)\n}\n",
        "path": "/aztec/address.nr"
      },
      "94": {
        "source": "use dep::protocol_types::constants::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    BlockHeader,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n    get_block_header::get_block_header,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_header: inputs.block_header,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: u32) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_header: BlockHeader {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    archive_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n",
        "path": "/aztec/context.nr"
      },
      "95": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse dep::protocol_types::constants::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    // TODO(#1205) This is probably not the right index to use\n    pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    pedersen_hash_with_separator(inputs, hash_index)\n}\n",
        "path": "/aztec/hash.nr"
      },
      "102": {
        "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse crate::types::point::Point;\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/aztec/log.nr"
      },
      "107": {
        "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse dep::protocol_types::constants::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note, note_interface: NoteInterface<Note, N>) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}\n",
        "path": "/aztec/note/lifecycle.nr"
      },
      "108": {
        "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>, note: Note) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(context: &mut PrivateContext, storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields)[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields);\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(storage_slot: Field, note_interface: NoteInterface<Note, N>, options: NoteViewerOptions<Note, N>) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields)\n}\n\nunconstrained fn flatten_options<Note, N>(selects: BoundedVec<Option<Select>, N>, sorts: BoundedVec<Option<Sort>, N>) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}\n",
        "path": "/aztec/note/note_getter.nr"
      },
      "110": {
        "source": "use crate::hash::pedersen_hash;\nuse dep::protocol_types::constants::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/aztec/note/note_hash.nr"
      },
      "114": {
        "source": "use dep::protocol_types::constants::GENERATOR_INDEX__OUTER_NULLIFIER;\nuse crate::{\n    note::{\n        note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n    utils::arr_copy_slice,\n    hash::pedersen_hash,\n};\n\npub fn compute_inner_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note_with_header);\n\n    let input = [header.contract_address, inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(note_interface: NoteInterface<Note, N>, note_with_header: Note) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(note_interface: NoteInterface<Note, N>, note_header: NoteHeader, serialized_note: [Field; S]) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/aztec/note/utils.nr"
      },
      "116": {
        "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n",
        "path": "/aztec/oracle/arguments.nr"
      },
      "117": {
        "source": "use dep::protocol_types::constants::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(_contract_address: Field, _function_selector: Field, _args_hash: Field) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained pub fn call_private_function_internal(contract_address: Field, function_selector: Field, args_hash: Field) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(contract_address, function_selector, args_hash)\n}\n",
        "path": "/aztec/oracle/call_private_function.nr"
      },
      "123": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: Field) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key_x = result[0];\n    let pub_key_y = result[1];\n    let partial_address = result[2];\n\n    let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n    assert(calculated_address == address);\n\n    Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/aztec/oracle/get_public_key.nr"
      },
      "124": {
        "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(_owner: Point) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\npub fn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
        "path": "/aztec/oracle/get_secret_key.nr"
      },
      "130": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(_storage_slot: Field, _serialized_note: [Field; N], _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(storage_slot: Field, serialized_note: [Field; N], inner_note_hash: Field) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        return_size,\n        placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS] // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n",
        "path": "/aztec/oracle/notes.nr"
      },
      "132": {
        "source": "use crate::types::point::Point;\nuse dep::protocol_types::constants::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(_contract_address: Field, _storage_slot: Field, _encryption_pub_key: Point, _preimage: [Field; N]) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(contract_address: Field, storage_slot: Field, encryption_pub_key: Point, preimage: [Field; N]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(contract_address, storage_slot, encryption_pub_key, preimage), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: Field, _event_selector: Field, _message: T) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(contract_address: Field, event_selector: Field, message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n",
        "path": "/aztec/oracle/logs.nr"
      },
      "133": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse dep::protocol_types::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::hash::pedersen_hash;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    pub fn hash(self) -> Field {\n        pedersen_hash([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n",
        "path": "/aztec/private_call_stack_item.nr"
      },
      "138": {
        "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse crate::hash::pedersen_hash;\n\n// docs:start:map\nstruct Map<V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<V> Map<V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Map<V> {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: Field) -> V {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
        "path": "/aztec/state_vars/map.nr"
      },
      "141": {
        "source": "use dep::std::option::Option;\nuse dep::protocol_types::constants::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__INITIALIZATION_NULLIFIER};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    get_secret_key::get_secret_key,\n    notes::check_nullifier_exists,\n};\nuse crate::hash::pedersen_hash;\n\npub fn compute_singleton_initialization_nullifier(storage_slot: Field, owner: Option<Field>) -> Field {\n    if owner.is_some() {\n        let secret = get_secret_key(owner.unwrap_unchecked());\n        pedersen_hash([storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER)\n    } else {\n        pedersen_hash([storage_slot], GENERATOR_INDEX__INITIALIZATION_NULLIFIER)\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note,\n        owner: Option<Field>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(\n        self,\n        new_note: &mut Note,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self, broadcast: bool) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n",
        "path": "/aztec/state_vars/singleton.nr"
      },
      "145": {
        "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}\n",
        "path": "/aztec/types/vec.nr"
      },
      "151": {
        "source": "pub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: Field) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// TODO(#3470): Copied over from https://github.com/AztecProtocol/aztec-packages/blob/a07c4bd47313be6aa604a63f37857eb0136b41ba/yarn-project/noir-protocol-circuits/src/crates/rollup-lib/src/base/base_rollup_inputs.nr#L599\n// move to a shared place?\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    dep::std::eddsa::lt_bytes32(lhs, rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    dep::std::eddsa::lt_bytes32(rhs, lhs)\n}",
        "path": "/aztec/utils.nr"
      },
      "152": {
        "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        get_secret_key::get_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal COUNTER_NOTE_LEN: Field = 3;\n\nstruct CounterNote {\n    owner: Field,\n    value: Field,\n    end: Field,\n    header: NoteHeader,\n}\n\nimpl CounterNote {\n    pub fn new(owner: Field, value: Field, end: Field) -> Self {\n        CounterNote {\n            owner,\n            value,\n            end,\n            header: NoteHeader::empty()\n        }\n    }\n\n    pub fn serialize(self) -> [Field; COUNTER_NOTE_LEN] {\n        [self.owner, self.value, self.end]\n    }\n\n    pub fn deserialize(serialized: [Field; COUNTER_NOTE_LEN]) -> Self {\n        CounterNote {\n            owner: serialized[0],\n            value: serialized[1],\n            end: serialized[2],\n            header: NoteHeader::empty()\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        pedersen_hash(self.serialize(), 0)\n    }\n\n    pub fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(CounterNoteMethods, self);\n        let secret = get_secret_key(self.owner);\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high\n        ], 0)\n    }\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            get_public_key(self.owner),\n            self.serialize()\n        );\n    }\n}\n\n\nfn deserialize(serialized: [Field; COUNTER_NOTE_LEN]) -> CounterNote {\n    CounterNote::deserialize(serialized)\n}\n\nfn serialize(note: CounterNote) -> [Field; COUNTER_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: CounterNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: CounterNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: CounterNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut CounterNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nfn broadcast(context: &mut PrivateContext, slot: Field, note: CounterNote) {\n    note.broadcast(context, slot)\n}\n\nglobal CounterNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast\n};",
        "path": "/home/jpag/Workground/aztec/statechannel/contracts/counter_channel/src/counter_note.nr"
      }
    }
  }
}